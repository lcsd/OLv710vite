{"version":3,"file":"kml-timezones.js","mappings":"+LAeA,MAsBMA,EAAS,IAAI,IAAY,CAC7BC,OAAQ,IAAI,IAAa,CACvBC,IAAK,yBACLC,OAAQ,IAAI,KAAI,CACdC,eAAe,MAGnBC,MA7BoB,SAAUC,GAC9B,MAAMC,EAAWD,EAAQE,IAAI,aACvBC,EAAQ,IAAIC,KAClBD,EAAME,QACJF,EAAMG,UAA4D,KAA/CH,EAAMI,qBAAuBN,GAAY,KAG9D,IAAIO,EAAQC,KAAKC,IAAI,IAAMP,EAAMQ,WAAaR,EAAMS,aAAe,KAC/DJ,EAAQ,KACVA,EAAQ,GAAKA,GAEf,MAAMK,EAAU,KAAQ,EAAIL,EAAQ,IACpC,OAAO,IAAI,KAAM,CACfM,KAAM,IAAI,IAAK,CACbC,MAAO,CAAC,IAAM,IAAM,GAAMF,KAE5BG,OAAQ,IAAI,IAAO,CACjBD,MAAO,aAGb,IA2BArB,EAAOuB,YAAYC,GAAG,mBAAmB,SAAUC,GACjDA,EAAIC,SAASC,SAAQ,SAAUrB,GAC7B,MAAMC,EAbV,SAA4BqB,GAC1B,MAAMC,EAAQD,EAAKC,MAAM,2BACzB,OAAKA,GAGqB,MAAbA,EAAM,IAAc,EAAI,IAGtB,GAFDC,OAAOD,EAAM,IACXC,OAAOD,EAAM,KAJpB,IAMX,CAIqBE,CAAmBzB,EAAQE,IAAI,SAChDF,EAAQ0B,IAAI,YAAazB,GAAU,EACrC,GACF,IAEA,MAAM0B,EAAS,IAAI,IAAU,CAC3BhC,OAAQ,IAAI,IAAO,CACjBiC,MAAO,YAILC,EAAM,IAAI,IAAI,CAClBC,OAAQ,CAACH,EAAQjC,GACjBqC,OAAQ,MACRC,KAAM,IAAI,KAAK,CACbC,OAAQ,CAAC,EAAG,GACZC,KAAM,MAIJC,EAAOC,SAASC,eAAe,QACrCF,EAAKpC,MAAMuC,cAAgB,OAC3B,MAAMC,EAAU,IAAIC,UAAUC,QAAQN,EAAM,CAC1CO,WAAW,EACXC,YAAa,UACbC,OAAQ,CAAC,EAAG,GACZC,MAAO,IACPC,QAAS,WAGX,IAAIC,EACJ,MAAMC,EAAqB,SAAUC,EAAOlB,GAC1C,MAAM/B,EAAU+B,EAAOmB,QAAQ,oBAC3BC,EACAtB,EAAIuB,sBAAsBH,GAAO,SAAUjD,GACzC,OAAOA,CACT,IACAA,GACFmC,EAAKpC,MAAMsD,KAAOJ,EAAM,GAAK,KAC7Bd,EAAKpC,MAAMuD,IAAML,EAAM,GAAK,KACxBjD,IAAY+C,GACdR,EAAQgB,WAAW,CAAC,iBAAkBvD,EAAQE,IAAI,UAEhD6C,EACFR,EAAQiB,SAERjB,EAAQkB,QAGVlB,EAAQmB,OAEVX,EAAiB/C,CACnB,EAEA6B,EAAIX,GAAG,eAAe,SAAUC,GAC9B,GAAIA,EAAIwC,SAGN,OAFApB,EAAQmB,YACRX,OAAiBI,GAGnB,MAAMF,EAAQpB,EAAI+B,cAAczC,EAAI0C,eACpCb,EAAmBC,EAAO9B,EAAI0C,cAAc9B,OAC9C,IAEAF,EAAIX,GAAG,SAAS,SAAUC,GACxB6B,EAAmB7B,EAAI8B,MAAO9B,EAAI0C,cAAc9B,OAClD,IAEAF,EAAIiC,mBAAmBC,iBAAiB,gBAAgB,WACtDxB,EAAQmB,OACRX,OAAiBI,CACnB,G","sources":["webpack:///./kml-timezones.js"],"sourcesContent":["import KML from '../src/ol/format/KML.js';\nimport Map from '../src/ol/Map.js';\nimport Stamen from '../src/ol/source/Stamen.js';\nimport VectorSource from '../src/ol/source/Vector.js';\nimport View from '../src/ol/View.js';\nimport {Fill, Stroke, Style} from '../src/ol/style.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\n\n/*\n * Compute the style of the feature.  Here we want the opacity of polygons to\n * be based on the offset from local noon.  For example, a timezone where it is\n * currently noon would have an opacity of 0.75.  And a timezone where it is\n * currently midnight would have an opacity of 0.  This doesn't account for\n * daylight savings, so don't use it to plan your vacation.\n */\nconst styleFunction = function (feature) {\n  const tzOffset = feature.get('tz-offset');\n  const local = new Date();\n  local.setTime(\n    local.getTime() + (local.getTimezoneOffset() + (tzOffset || 0)) * 60000\n  );\n  // offset from local noon (in hours)\n  let delta = Math.abs(12 - (local.getHours() + local.getMinutes() / 60));\n  if (delta > 12) {\n    delta = 24 - delta;\n  }\n  const opacity = 0.75 * (1 - delta / 12);\n  return new Style({\n    fill: new Fill({\n      color: [0xff, 0xff, 0x33, opacity],\n    }),\n    stroke: new Stroke({\n      color: '#ffffff',\n    }),\n  });\n};\n\nconst vector = new VectorLayer({\n  source: new VectorSource({\n    url: 'data/kml/timezones.kml',\n    format: new KML({\n      extractStyles: false,\n    }),\n  }),\n  style: styleFunction,\n});\n\n/**\n * @param {string} name e.g. GMT -08:30\n * @return {number|null} The offset from UTC in minutes\n */\nfunction parseOffsetFromUtc(name) {\n  const match = name.match(/([+-]?)(\\d{2}):(\\d{2})$/);\n  if (!match) {\n    return null;\n  }\n  const sign = match[1] === '-' ? -1 : 1;\n  const hours = Number(match[2]);\n  const minutes = Number(match[3]);\n  return sign * (60 * hours + minutes);\n}\n\nvector.getSource().on('featuresloadend', function (evt) {\n  evt.features.forEach(function (feature) {\n    const tzOffset = parseOffsetFromUtc(feature.get('name'));\n    feature.set('tz-offset', tzOffset, true);\n  });\n});\n\nconst raster = new TileLayer({\n  source: new Stamen({\n    layer: 'toner',\n  }),\n});\n\nconst map = new Map({\n  layers: [raster, vector],\n  target: 'map',\n  view: new View({\n    center: [0, 0],\n    zoom: 2,\n  }),\n});\n\nconst info = document.getElementById('info');\ninfo.style.pointerEvents = 'none';\nconst tooltip = new bootstrap.Tooltip(info, {\n  animation: false,\n  customClass: 'pe-none',\n  offset: [0, 5],\n  title: '-',\n  trigger: 'manual',\n});\n\nlet currentFeature;\nconst displayFeatureInfo = function (pixel, target) {\n  const feature = target.closest('.ol-control')\n    ? undefined\n    : map.forEachFeatureAtPixel(pixel, function (feature) {\n        return feature;\n      });\n  if (feature) {\n    info.style.left = pixel[0] + 'px';\n    info.style.top = pixel[1] + 'px';\n    if (feature !== currentFeature) {\n      tooltip.setContent({'.tooltip-inner': feature.get('name')});\n    }\n    if (currentFeature) {\n      tooltip.update();\n    } else {\n      tooltip.show();\n    }\n  } else {\n    tooltip.hide();\n  }\n  currentFeature = feature;\n};\n\nmap.on('pointermove', function (evt) {\n  if (evt.dragging) {\n    tooltip.hide();\n    currentFeature = undefined;\n    return;\n  }\n  const pixel = map.getEventPixel(evt.originalEvent);\n  displayFeatureInfo(pixel, evt.originalEvent.target);\n});\n\nmap.on('click', function (evt) {\n  displayFeatureInfo(evt.pixel, evt.originalEvent.target);\n});\n\nmap.getTargetElement().addEventListener('pointerleave', function () {\n  tooltip.hide();\n  currentFeature = undefined;\n});\n"],"names":["vector","source","url","format","extractStyles","style","feature","tzOffset","get","local","Date","setTime","getTime","getTimezoneOffset","delta","Math","abs","getHours","getMinutes","opacity","fill","color","stroke","getSource","on","evt","features","forEach","name","match","Number","parseOffsetFromUtc","set","raster","layer","map","layers","target","view","center","zoom","info","document","getElementById","pointerEvents","tooltip","bootstrap","Tooltip","animation","customClass","offset","title","trigger","currentFeature","displayFeatureInfo","pixel","closest","undefined","forEachFeatureAtPixel","left","top","setContent","update","show","hide","dragging","getEventPixel","originalEvent","getTargetElement","addEventListener"],"sourceRoot":""}