{"version":3,"file":"wkb.js","mappings":"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","sources":["webpack:///../src/ol/format/WKB.js","webpack:///./wkb.js"],"sourcesContent":["/**\n * @module ol/format/WKB\n */\nimport Feature from '../Feature.js';\nimport FeatureFormat, {transformGeometryWithOptions} from './Feature.js';\nimport GeometryCollection from '../geom/GeometryCollection.js';\nimport LineString from '../geom/LineString.js';\nimport MultiLineString from '../geom/MultiLineString.js';\nimport MultiPoint from '../geom/MultiPoint.js';\nimport MultiPolygon from '../geom/MultiPolygon.js';\nimport Point from '../geom/Point.js';\nimport Polygon from '../geom/Polygon.js';\nimport {get as getProjection} from '../proj.js';\n\nimport SimpleGeometry from '../geom/SimpleGeometry.js';\n\n// WKB spec: https://www.ogc.org/standards/sfa\n// EWKB spec: https://raw.githubusercontent.com/postgis/postgis/2.1.0/doc/ZMSgeoms.txt\n\n/**\n * @const\n * @enum {number}\n */\nconst WKBGeometryType = {\n  POINT: 1,\n  LINE_STRING: 2,\n  POLYGON: 3,\n  MULTI_POINT: 4,\n  MULTI_LINE_STRING: 5,\n  MULTI_POLYGON: 6,\n  GEOMETRY_COLLECTION: 7,\n\n  /*\n  CIRCULAR_STRING: 8,\n  COMPOUND_CURVE: 9,\n  CURVE_POLYGON: 10,\n\n  MULTI_CURVE: 11,\n  MULTI_SURFACE: 12,\n  CURVE: 13,\n  SURFACE: 14,\n  */\n\n  POLYHEDRAL_SURFACE: 15,\n  TIN: 16,\n  TRIANGLE: 17,\n};\n\nclass WkbReader {\n  /**\n   * @param {DataView} view source to read\n   */\n  constructor(view) {\n    /** @private */\n    this.view_ = view;\n\n    /**\n     * @type {number}\n     * @private\n     */\n    this.pos_ = 0;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.initialized_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.isLittleEndian_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasZ_ = false;\n\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.hasM_ = false;\n\n    /**\n     * @type {number|null}\n     * @private\n     */\n    this.srid_ = null;\n\n    /**\n     * @type {import(\"../geom/Geometry.js\").GeometryLayout}\n     * @private\n     */\n    this.layout_ = 'XY';\n  }\n\n  /**\n   * @return {number} value\n   */\n  readUint8() {\n    return this.view_.getUint8(this.pos_++);\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readUint32(isLittleEndian) {\n    return this.view_.getUint32(\n      (this.pos_ += 4) - 4,\n      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_\n    );\n  }\n\n  /**\n   * @param {boolean} [isLittleEndian] Whether read value as little endian\n   * @return {number} value\n   */\n  readDouble(isLittleEndian) {\n    return this.view_.getFloat64(\n      (this.pos_ += 8) - 8,\n      isLittleEndian !== undefined ? isLittleEndian : this.isLittleEndian_\n    );\n  }\n\n  /**\n   * @return {import('../coordinate.js').Coordinate} coords for Point\n   */\n  readPoint() {\n    /** @type import('../coordinate.js').Coordinate */\n    const coords = [];\n\n    coords.push(this.readDouble());\n    coords.push(this.readDouble());\n    if (this.hasZ_) {\n      coords.push(this.readDouble());\n    }\n    if (this.hasM_) {\n      coords.push(this.readDouble());\n    }\n\n    return coords;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for LineString / LinearRing\n   */\n  readLineString() {\n    const numPoints = this.readUint32();\n\n    /** @type Array<import('../coordinate.js').Coordinate> */\n    const coords = [];\n    for (let i = 0; i < numPoints; i++) {\n      coords.push(this.readPoint());\n    }\n\n    return coords;\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for Polygon like\n   */\n  readPolygon() {\n    const numRings = this.readUint32();\n\n    /** @type Array<Array<import('../coordinate.js').Coordinate>> */\n    const rings = [];\n    for (let i = 0; i < numRings; i++) {\n      rings.push(this.readLineString()); // as a LinearRing\n    }\n\n    return rings;\n  }\n\n  /**\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {number} WKB Type ID\n   */\n  readWkbHeader(expectedTypeId) {\n    const byteOrder = this.readUint8();\n    const isLittleEndian = byteOrder > 0;\n\n    const wkbType = this.readUint32(isLittleEndian);\n    const wkbTypeThousandth = Math.floor((wkbType & 0x0fffffff) / 1000);\n    const hasZ =\n      Boolean(wkbType & 0x80000000) ||\n      wkbTypeThousandth === 1 ||\n      wkbTypeThousandth === 3;\n    const hasM =\n      Boolean(wkbType & 0x40000000) ||\n      wkbTypeThousandth === 2 ||\n      wkbTypeThousandth === 3;\n    const hasSRID = Boolean(wkbType & 0x20000000);\n    const typeId = (wkbType & 0x0fffffff) % 1000; // Assume 1000 is an upper limit for type ID\n    const layout = /** @type {import(\"../geom/Geometry.js\").GeometryLayout} */ (\n      ['XY', hasZ ? 'Z' : '', hasM ? 'M' : ''].join('')\n    );\n\n    const srid = hasSRID ? this.readUint32(isLittleEndian) : null;\n\n    if (expectedTypeId !== undefined && expectedTypeId !== typeId) {\n      throw new Error('Unexpected WKB geometry type ' + typeId);\n    }\n\n    if (this.initialized_) {\n      // sanity checks\n      if (this.isLittleEndian_ !== isLittleEndian) {\n        throw new Error('Inconsistent endian');\n      }\n      if (this.layout_ !== layout) {\n        throw new Error('Inconsistent geometry layout');\n      }\n      if (srid && this.srid_ !== srid) {\n        throw new Error('Inconsistent coordinate system (SRID)');\n      }\n    } else {\n      this.isLittleEndian_ = isLittleEndian;\n      this.hasZ_ = hasZ;\n      this.hasM_ = hasM;\n      this.layout_ = layout;\n      this.srid_ = srid;\n      this.initialized_ = true;\n    }\n\n    return typeId;\n  }\n\n  /**\n   * @param {number} typeId WKB Type ID\n   * @return {any} values read\n   */\n  readWkbPayload(typeId) {\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return this.readPoint();\n\n      case WKBGeometryType.LINE_STRING:\n        return this.readLineString();\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return this.readPolygon();\n\n      case WKBGeometryType.MULTI_POINT:\n        return this.readMultiPoint();\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return this.readMultiLineString();\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return this.readMultiPolygon();\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return this.readGeometryCollection();\n\n      default:\n        throw new Error(\n          'Unsupported WKB geometry type ' + typeId + ' is found'\n        );\n    }\n  }\n\n  /**\n   * @param {number} expectedTypeId Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbBlock(expectedTypeId) {\n    return this.readWkbPayload(this.readWkbHeader(expectedTypeId));\n  }\n\n  /**\n   * @param {Function} reader reader function for each item\n   * @param {number} [expectedTypeId] Expected WKB Type ID\n   * @return {any} values read\n   */\n  readWkbCollection(reader, expectedTypeId) {\n    const num = this.readUint32();\n\n    const items = [];\n    for (let i = 0; i < num; i++) {\n      const result = reader.call(this, expectedTypeId);\n      if (result) {\n        items.push(result);\n      }\n    }\n\n    return items;\n  }\n\n  /**\n   * @return {Array<import('../coordinate.js').Coordinate>} coords for MultiPoint\n   */\n  readMultiPoint() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POINT);\n  }\n\n  /**\n   * @return {Array<Array<import('../coordinate.js').Coordinate>>} coords for MultiLineString like\n   */\n  readMultiLineString() {\n    return this.readWkbCollection(\n      this.readWkbBlock,\n      WKBGeometryType.LINE_STRING\n    );\n  }\n\n  /**\n   * @return {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords for MultiPolygon like\n   */\n  readMultiPolygon() {\n    return this.readWkbCollection(this.readWkbBlock, WKBGeometryType.POLYGON);\n  }\n\n  /**\n   * @return {Array<import('../geom/Geometry.js').default>} array of geometries\n   */\n  readGeometryCollection() {\n    return this.readWkbCollection(this.readGeometry);\n  }\n\n  /**\n   * @return {import('../geom/Geometry.js').default} geometry\n   */\n  readGeometry() {\n    const typeId = this.readWkbHeader();\n    const result = this.readWkbPayload(typeId);\n\n    switch (typeId) {\n      case WKBGeometryType.POINT:\n        return new Point(\n          /** @type {import('../coordinate.js').Coordinate} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.LINE_STRING:\n        return new LineString(\n          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.POLYGON:\n      case WKBGeometryType.TRIANGLE:\n        return new Polygon(\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_POINT:\n        return new MultiPoint(\n          /** @type {Array<import('../coordinate.js').Coordinate>} */ (result),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_LINE_STRING:\n        return new MultiLineString(\n          /** @type {Array<Array<import('../coordinate.js').Coordinate>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.MULTI_POLYGON:\n      case WKBGeometryType.POLYHEDRAL_SURFACE:\n      case WKBGeometryType.TIN:\n        return new MultiPolygon(\n          /** @type {Array<Array<Array<import('../coordinate.js').Coordinate>>>} */ (\n            result\n          ),\n          this.layout_\n        );\n\n      case WKBGeometryType.GEOMETRY_COLLECTION:\n        return new GeometryCollection(\n          /** @type {Array<import('../geom/Geometry.js').default>} */ (result)\n        );\n\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * @return {number|null} SRID in the EWKB. `null` if not defined.\n   */\n  getSrid() {\n    return this.srid_;\n  }\n}\n\nclass WkbWriter {\n  /**\n   * @type {Object}\n   * @property {string} [layout] geometryLayout\n   * @property {boolean} [littleEndian=true] littleEndian\n   * @property {boolean} [ewkb=true] Whether writes in EWKB format\n   * @property {Object} [nodata] NoData value for each axes\n   * @param {Object} opts options\n   */\n  constructor(opts) {\n    opts = opts || {};\n\n    /** @type {string} */\n    this.layout_ = opts.layout;\n    this.isLittleEndian_ = opts.littleEndian !== false;\n\n    this.isEWKB_ = opts.ewkb !== false;\n\n    /** @type {Array<Array<number>>} */\n    this.writeQueue_ = [];\n\n    /**\n     * @type {Object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} Z NoData value for Z\n     * @property {number} M NoData value for M\n     */\n    this.nodata_ = Object.assign({X: 0, Y: 0, Z: 0, M: 0}, opts.nodata);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint8(value) {\n    this.writeQueue_.push([1, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeUint32(value) {\n    this.writeQueue_.push([4, value]);\n  }\n\n  /**\n   * @param {number} value value\n   */\n  writeDouble(value) {\n    this.writeQueue_.push([8, value]);\n  }\n\n  /**\n   * @param {import('../coordinate.js').Coordinate} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writePoint(coords, layout) {\n    /**\n     * @type {Object}\n     * @property {number} X NoData value for X\n     * @property {number} Y NoData value for Y\n     * @property {number} [Z] NoData value for Z\n     * @property {number} [M] NoData value for M\n     */\n    const coordsObj = Object.assign.apply(\n      null,\n      layout.split('').map((axis, idx) => ({[axis]: coords[idx]}))\n    );\n\n    for (const axis of this.layout_) {\n      this.writeDouble(\n        axis in coordsObj ? coordsObj[axis] : this.nodata_[axis]\n      );\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeLineString(coords, layout) {\n    this.writeUint32(coords.length); // numPoints\n    for (let i = 0; i < coords.length; i++) {\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} rings rings\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writePolygon(rings, layout) {\n    this.writeUint32(rings.length); // numRings\n    for (let i = 0; i < rings.length; i++) {\n      this.writeLineString(rings[i], layout); // as a LinearRing\n    }\n  }\n\n  /**\n   * @param {number} wkbType WKB Type ID\n   * @param {number} [srid] SRID\n   */\n  writeWkbHeader(wkbType, srid) {\n    wkbType %= 1000; // Assume 1000 is an upper limit for type ID\n    if (this.layout_.includes('Z')) {\n      wkbType += this.isEWKB_ ? 0x80000000 : 1000;\n    }\n    if (this.layout_.includes('M')) {\n      wkbType += this.isEWKB_ ? 0x40000000 : 2000;\n    }\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      wkbType |= 0x20000000;\n    }\n\n    this.writeUint8(this.isLittleEndian_ ? 1 : 0);\n    this.writeUint32(wkbType);\n    if (this.isEWKB_ && Number.isInteger(srid)) {\n      this.writeUint32(srid);\n    }\n  }\n\n  /**\n   * @param {Array<import('../coordinate.js').Coordinate>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiPoint(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(1);\n      this.writePoint(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<import('../coordinate.js').Coordinate>>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiLineString(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(2);\n      this.writeLineString(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<Array<Array<import('../coordinate.js').Coordinate>>>} coords coords\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} layout layout\n   */\n  writeMultiPolygon(coords, layout) {\n    this.writeUint32(coords.length); // numItems\n    for (let i = 0; i < coords.length; i++) {\n      this.writeWkbHeader(3);\n      this.writePolygon(coords[i], layout);\n    }\n  }\n\n  /**\n   * @param {Array<import('../geom/Geometry.js').default>} geometries geometries\n   */\n  writeGeometryCollection(geometries) {\n    this.writeUint32(geometries.length); // numItems\n\n    for (let i = 0; i < geometries.length; i++) {\n      this.writeGeometry(geometries[i]);\n    }\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {import(\"../geom/Geometry.js\").GeometryLayout} [layout] layout\n   * @return {import(\"../geom/Geometry.js\").GeometryLayout} minumum layout made by common axes\n   */\n  findMinimumLayout(geom, layout = 'XYZM') {\n    /**\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} a A\n     * @param {import(\"../geom/Geometry.js\").GeometryLayout} b B\n     * @return {import(\"../geom/Geometry.js\").GeometryLayout} minumum layout made by common axes\n     */\n    const GeometryLayout_min = (a, b) => {\n      if (a === b) {\n        return a;\n      }\n\n      if (a === 'XYZM') {\n        // anything `b` is minimum\n        return b;\n      }\n      if (b === 'XYZM') {\n        // anything `a` is minimum\n        return a;\n      }\n\n      // otherwise, incompatible\n      return 'XY';\n    };\n\n    if (geom instanceof SimpleGeometry) {\n      return GeometryLayout_min(geom.getLayout(), layout);\n    }\n\n    if (geom instanceof GeometryCollection) {\n      const geoms = geom.getGeometriesArray();\n      for (let i = 0; i < geoms.length && layout !== 'XY'; i++) {\n        layout = this.findMinimumLayout(geoms[i], layout);\n      }\n    }\n\n    return layout;\n  }\n\n  /**\n   * @param {import(\"../geom/Geometry.js\").default} geom geometry\n   * @param {number} [srid] SRID\n   */\n  writeGeometry(geom, srid) {\n    /**\n     * @type {Object<import(\"../geom/Geometry.js\").Type, WKBGeometryType>}\n     */\n    const wkblut = {\n      Point: WKBGeometryType.POINT,\n      LineString: WKBGeometryType.LINE_STRING,\n      Polygon: WKBGeometryType.POLYGON,\n      MultiPoint: WKBGeometryType.MULTI_POINT,\n      MultiLineString: WKBGeometryType.MULTI_LINE_STRING,\n      MultiPolygon: WKBGeometryType.MULTI_POLYGON,\n      GeometryCollection: WKBGeometryType.GEOMETRY_COLLECTION,\n    };\n    const geomType = geom.getType();\n    const typeId = wkblut[geomType];\n\n    if (!typeId) {\n      throw new Error('GeometryType ' + geomType + ' is not supported');\n    }\n\n    // first call of writeGeometry() traverse whole geometries to determine its output layout if not specified on constructor.\n    if (!this.layout_) {\n      this.layout_ = this.findMinimumLayout(geom);\n    }\n\n    this.writeWkbHeader(typeId, srid);\n\n    if (geom instanceof SimpleGeometry) {\n      const writerLUT = {\n        Point: this.writePoint,\n        LineString: this.writeLineString,\n        Polygon: this.writePolygon,\n        MultiPoint: this.writeMultiPoint,\n        MultiLineString: this.writeMultiLineString,\n        MultiPolygon: this.writeMultiPolygon,\n      };\n      writerLUT[geomType].call(this, geom.getCoordinates(), geom.getLayout());\n    } else if (geom instanceof GeometryCollection) {\n      this.writeGeometryCollection(geom.getGeometriesArray());\n    }\n  }\n\n  getBuffer() {\n    const byteLength = this.writeQueue_.reduce((acc, item) => acc + item[0], 0);\n    const buffer = new ArrayBuffer(byteLength);\n    const view = new DataView(buffer);\n\n    let pos = 0;\n    this.writeQueue_.forEach((item) => {\n      switch (item[0]) {\n        case 1:\n          view.setUint8(pos, item[1]);\n          break;\n        case 4:\n          view.setUint32(pos, item[1], this.isLittleEndian_);\n          break;\n        case 8:\n          view.setFloat64(pos, item[1], this.isLittleEndian_);\n          break;\n        default:\n          break;\n      }\n\n      pos += item[0];\n    });\n\n    return buffer;\n  }\n}\n\n/**\n * @typedef {Object} Options\n * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into multiple features on reading.\n * @property {boolean} [hex=true] Returns hex string instead of ArrayBuffer for output. This also is used as a hint internally whether it should load contents as text or ArrayBuffer on reading.\n * @property {boolean} [littleEndian=true] Use littleEndian for output.\n * @property {boolean} [ewkb=true] Use EWKB format for output.\n * @property {import(\"../geom/Geometry.js\").GeometryLayout} [geometryLayout=null] Use specific coordinate layout for output features (null: auto detect)\n * @property {number} [nodataZ=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of Z.\n * @property {number} [nodataM=0] If the `geometryLayout` doesn't match with geometry to be output, this value is used to fill missing coordinate value of M.\n * @property {number|boolean} [srid=true] SRID for output. Specify integer value to enforce the value as a SRID. Specify `true` to extract from `dataProjection`. `false` to suppress the output. This option only takes effect when `ewkb` is `true`.\n */\n\n/**\n * @classdesc\n * Geometry format for reading and writing data in the `Well-Known Binary` (WKB) format.\n * Also supports `Extended Well-Known Binary` (EWKB) format, used in PostGIS for example.\n *\n * @api\n */\nclass WKB extends FeatureFormat {\n  /**\n   * @param {Options} [options] Optional configuration object.\n   */\n  constructor(options) {\n    super();\n\n    options = options ? options : {};\n\n    this.splitCollection = Boolean(options.splitCollection);\n\n    this.viewCache_ = null;\n\n    this.hex_ = options.hex !== false;\n    this.littleEndian_ = options.littleEndian !== false;\n    this.ewkb_ = options.ewkb !== false;\n\n    this.layout_ = options.geometryLayout; // null for auto detect\n    this.nodataZ_ = options.nodataZ || 0;\n    this.nodataM_ = options.nodataM || 0;\n\n    this.srid_ = options.srid;\n  }\n\n  /**\n   * @return {import(\"./Feature.js\").Type} Format.\n   */\n  getType() {\n    return this.hex_ ? 'text' : 'arraybuffer';\n  }\n\n  /**\n   * Read a single feature from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../Feature.js\").default} Feature.\n   * @api\n   */\n  readFeature(source, options) {\n    return new Feature({\n      geometry: this.readGeometry(source, options),\n    });\n  }\n\n  /**\n   * Read all features from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {Array<import(\"../Feature.js\").default>} Features.\n   * @api\n   */\n  readFeatures(source, options) {\n    let geometries = [];\n    const geometry = this.readGeometry(source, options);\n    if (this.splitCollection && geometry instanceof GeometryCollection) {\n      geometries = geometry.getGeometriesArray();\n    } else {\n      geometries = [geometry];\n    }\n    return geometries.map((geometry) => new Feature({geometry}));\n  }\n\n  /**\n   * Read a single geometry from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @param {import(\"./Feature.js\").ReadOptions} [options] Read options.\n   * @return {import(\"../geom/Geometry.js\").default} Geometry.\n   * @api\n   */\n  readGeometry(source, options) {\n    const view = getDataView(source);\n    if (!view) {\n      return null;\n    }\n\n    const reader = new WkbReader(view);\n    const geometry = reader.readGeometry();\n\n    this.viewCache_ = view; // cache for internal subsequent call of readProjection()\n    options = this.getReadOptions(source, options);\n    this.viewCache_ = null; // release\n\n    return transformGeometryWithOptions(geometry, false, options);\n  }\n\n  /**\n   * Read the projection from a source.\n   *\n   * @param {string|ArrayBuffer|ArrayBufferView} source Source.\n   * @return {import(\"../proj/Projection.js\").default|undefined} Projection.\n   * @api\n   */\n  readProjection(source) {\n    const view = this.viewCache_ || getDataView(source);\n    if (!view) {\n      return undefined;\n    }\n\n    const reader = new WkbReader(view);\n    reader.readWkbHeader();\n\n    return (\n      (reader.getSrid() && getProjection('EPSG:' + reader.getSrid())) ||\n      undefined\n    );\n  }\n\n  /**\n   * Encode a feature in this format.\n   *\n   * @param {import(\"../Feature.js\").default} feature Feature.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeature(feature, options) {\n    return this.writeGeometry(feature.getGeometry(), options);\n  }\n\n  /**\n   * Encode an array of features in this format.\n   *\n   * @param {Array<import(\"../Feature.js\").default>} features Features.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeFeatures(features, options) {\n    return this.writeGeometry(\n      new GeometryCollection(features.map((f) => f.getGeometry())),\n      options\n    );\n  }\n\n  /**\n   * Write a single geometry in this format.\n   *\n   * @param {import(\"../geom/Geometry.js\").default} geometry Geometry.\n   * @param {import(\"./Feature.js\").WriteOptions} [options] Write options.\n   * @return {string|ArrayBuffer} Result.\n   * @api\n   */\n  writeGeometry(geometry, options) {\n    options = this.adaptOptions(options);\n\n    const writer = new WkbWriter({\n      layout: this.layout_,\n      littleEndian: this.littleEndian_,\n      ewkb: this.ewkb_,\n\n      nodata: {\n        Z: this.nodataZ_,\n        M: this.nodataM_,\n      },\n    });\n\n    // extract SRID from `dataProjection`\n    let srid = Number.isInteger(this.srid_) ? Number(this.srid_) : null;\n    if (this.srid_ !== false && !Number.isInteger(this.srid_)) {\n      const dataProjection =\n        options.dataProjection && getProjection(options.dataProjection);\n      if (dataProjection) {\n        const code = dataProjection.getCode();\n        if (code.startsWith('EPSG:')) {\n          srid = Number(code.substring(5));\n        }\n      }\n    }\n\n    writer.writeGeometry(\n      transformGeometryWithOptions(geometry, true, options),\n      srid\n    );\n    const buffer = writer.getBuffer();\n\n    return this.hex_ ? encodeHexString(buffer) : buffer;\n  }\n}\n\n/**\n * @param {ArrayBuffer} buffer source buffer\n * @return {string} encoded hex string\n */\nfunction encodeHexString(buffer) {\n  const view = new Uint8Array(buffer);\n  return Array.from(view.values())\n    .map((x) => (x < 16 ? '0' : '') + Number(x).toString(16).toUpperCase())\n    .join('');\n}\n\n/**\n * @param {string} text source text\n * @return {DataView} decoded binary buffer\n */\nfunction decodeHexString(text) {\n  const buffer = new Uint8Array(text.length / 2);\n  for (let i = 0; i < text.length / 2; i++) {\n    buffer[i] = parseInt(text.substr(i * 2, 2), 16);\n  }\n  return new DataView(buffer.buffer);\n}\n\n/**\n * @param {string | ArrayBuffer | ArrayBufferView} source source\n * @return {DataView} data view\n */\nfunction getDataView(source) {\n  if (typeof source === 'string') {\n    return decodeHexString(source);\n  } else if (ArrayBuffer.isView(source)) {\n    if (source instanceof DataView) {\n      return source;\n    }\n    return new DataView(source.buffer, source.byteOffset, source.byteLength);\n  } else if (source instanceof ArrayBuffer) {\n    return new DataView(source);\n  } else {\n    return null;\n  }\n}\n\nexport default WKB;\n","import Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport WKB from '../src/ol/format/WKB.js';\nimport {OSM, Vector as VectorSource} from '../src/ol/source.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\n\nconst raster = new TileLayer({\n  source: new OSM(),\n});\n\nconst wkb =\n  '0103000000010000000500000054E3A59BC4602540643BDF4F8D1739C05C8FC2F5284C4140EC51B81E852B34C0D578E926316843406F1283C0CAD141C01B2FDD2406012B40A4703D0AD79343C054E3A59BC4602540643BDF4F8D1739C0';\n\nconst format = new WKB();\n\nconst feature = format.readFeature(wkb, {\n  dataProjection: 'EPSG:4326',\n  featureProjection: 'EPSG:3857',\n});\n\nconst vector = new VectorLayer({\n  source: new VectorSource({\n    features: [feature],\n  }),\n});\n\nconst map = new Map({\n  layers: [raster, vector],\n  target: 'map',\n  view: new View({\n    center: [2952104.0199, -3277504.823],\n    zoom: 4,\n  }),\n});\n"],"names":["WKBGeometryType","WkbReader","constructor","view","this","view_","pos_","initialized_","isLittleEndian_","hasZ_","hasM_","srid_","layout_","readUint8","getUint8","readUint32","isLittleEndian","getUint32","undefined","readDouble","getFloat64","readPoint","coords","push","readLineString","numPoints","i","readPolygon","numRings","rings","readWkbHeader","expectedTypeId","wkbType","wkbTypeThousandth","Math","floor","hasZ","Boolean","hasM","hasSRID","typeId","layout","join","srid","Error","readWkbPayload","readMultiPoint","readMultiLineString","readMultiPolygon","readGeometryCollection","readWkbBlock","readWkbCollection","reader","num","items","result","call","readGeometry","Point","LineString","Polygon","MultiPoint","MultiLineString","MultiPolygon","GeometryCollection","getSrid","WkbWriter","opts","littleEndian","isEWKB_","ewkb","writeQueue_","nodata_","Object","assign","X","Y","Z","M","nodata","writeUint8","value","writeUint32","writeDouble","writePoint","coordsObj","apply","split","map","axis","idx","writeLineString","length","writePolygon","writeWkbHeader","includes","Number","isInteger","writeMultiPoint","writeMultiLineString","writeMultiPolygon","writeGeometryCollection","geometries","writeGeometry","findMinimumLayout","geom","SimpleGeometry","a","getLayout","b","geoms","getGeometriesArray","wkblut","geomType","getType","getCoordinates","getBuffer","byteLength","reduce","acc","item","buffer","ArrayBuffer","DataView","pos","forEach","setUint8","setUint32","setFloat64","WKB","options","super","splitCollection","viewCache_","hex_","hex","littleEndian_","ewkb_","geometryLayout","nodataZ_","nodataZ","nodataM_","nodataM","readFeature","source","Feature","geometry","readFeatures","getDataView","getReadOptions","readProjection","writeFeature","feature","getGeometry","writeFeatures","features","f","adaptOptions","writer","dataProjection","code","getCode","startsWith","substring","Uint8Array","Array","from","values","x","toString","toUpperCase","encodeHexString","text","parseInt","substr","decodeHexString","isView","byteOffset","raster","Tile","OSM","featureProjection","vector","Vector","Map","layers","target","View","center","zoom"],"sourceRoot":""}