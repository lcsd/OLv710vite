{"version":3,"file":"clusters-dynamic.js","mappings":"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","sources":["webpack:///./clusters-dynamic.js"],"sourcesContent":["import Feature from '../src/ol/Feature.js';\nimport GeoJSON from '../src/ol/format/GeoJSON.js';\nimport Map from '../src/ol/Map.js';\nimport View from '../src/ol/View.js';\nimport {\n  Circle as CircleStyle,\n  Fill,\n  Icon,\n  Stroke,\n  Style,\n  Text,\n} from '../src/ol/style.js';\nimport {Cluster, Vector as VectorSource, XYZ} from '../src/ol/source.js';\nimport {LineString, Point, Polygon} from '../src/ol/geom.js';\nimport {Tile as TileLayer, Vector as VectorLayer} from '../src/ol/layer.js';\nimport {createEmpty, extend, getWidth} from '../src/ol/extent.js';\nimport {fromLonLat} from '../src/ol/proj.js';\n\nconst circleDistanceMultiplier = 1;\nconst circleFootSeparation = 28;\nconst circleStartAngle = Math.PI / 2;\n\nconst convexHullFill = new Fill({\n  color: 'rgba(255, 153, 0, 0.4)',\n});\nconst convexHullStroke = new Stroke({\n  color: 'rgba(204, 85, 0, 1)',\n  width: 1.5,\n});\nconst outerCircleFill = new Fill({\n  color: 'rgba(255, 153, 102, 0.3)',\n});\nconst innerCircleFill = new Fill({\n  color: 'rgba(255, 165, 0, 0.7)',\n});\nconst textFill = new Fill({\n  color: '#fff',\n});\nconst textStroke = new Stroke({\n  color: 'rgba(0, 0, 0, 0.6)',\n  width: 3,\n});\nconst innerCircle = new CircleStyle({\n  radius: 14,\n  fill: innerCircleFill,\n});\nconst outerCircle = new CircleStyle({\n  radius: 20,\n  fill: outerCircleFill,\n});\nconst darkIcon = new Icon({\n  src: 'data/icons/emoticon-cool.svg',\n});\nconst lightIcon = new Icon({\n  src: 'data/icons/emoticon-cool-outline.svg',\n});\n\n/**\n * Single feature style, users for clusters with 1 feature and cluster circles.\n * @param {Feature} clusterMember A feature from a cluster.\n * @return {Style} An icon style for the cluster member's location.\n */\nfunction clusterMemberStyle(clusterMember) {\n  return new Style({\n    geometry: clusterMember.getGeometry(),\n    image: clusterMember.get('LEISTUNG') > 5 ? darkIcon : lightIcon,\n  });\n}\n\nlet clickFeature, clickResolution;\n/**\n * Style for clusters with features that are too close to each other, activated on click.\n * @param {Feature} cluster A cluster with overlapping members.\n * @param {number} resolution The current view resolution.\n * @return {Style} A style to render an expanded view of the cluster members.\n */\nfunction clusterCircleStyle(cluster, resolution) {\n  if (cluster !== clickFeature || resolution !== clickResolution) {\n    return;\n  }\n  const clusterMembers = cluster.get('features');\n  const centerCoordinates = cluster.getGeometry().getCoordinates();\n  return generatePointsCircle(\n    clusterMembers.length,\n    cluster.getGeometry().getCoordinates(),\n    resolution\n  ).reduce((styles, coordinates, i) => {\n    const point = new Point(coordinates);\n    const line = new LineString([centerCoordinates, coordinates]);\n    styles.unshift(\n      new Style({\n        geometry: line,\n        stroke: convexHullStroke,\n      })\n    );\n    styles.push(\n      clusterMemberStyle(\n        new Feature({\n          ...clusterMembers[i].getProperties(),\n          geometry: point,\n        })\n      )\n    );\n    return styles;\n  }, []);\n}\n\n/**\n * From\n * https://github.com/Leaflet/Leaflet.markercluster/blob/31360f2/src/MarkerCluster.Spiderfier.js#L55-L72\n * Arranges points in a circle around the cluster center, with a line pointing from the center to\n * each point.\n * @param {number} count Number of cluster members.\n * @param {Array<number>} clusterCenter Center coordinate of the cluster.\n * @param {number} resolution Current view resolution.\n * @return {Array<Array<number>>} An array of coordinates representing the cluster members.\n */\nfunction generatePointsCircle(count, clusterCenter, resolution) {\n  const circumference =\n    circleDistanceMultiplier * circleFootSeparation * (2 + count);\n  let legLength = circumference / (Math.PI * 2); //radius from circumference\n  const angleStep = (Math.PI * 2) / count;\n  const res = [];\n  let angle;\n\n  legLength = Math.max(legLength, 35) * resolution; // Minimum distance to get outside the cluster icon.\n\n  for (let i = 0; i < count; ++i) {\n    // Clockwise, like spiral.\n    angle = circleStartAngle + i * angleStep;\n    res.push([\n      clusterCenter[0] + legLength * Math.cos(angle),\n      clusterCenter[1] + legLength * Math.sin(angle),\n    ]);\n  }\n\n  return res;\n}\n\nlet hoverFeature;\n/**\n * Style for convex hulls of clusters, activated on hover.\n * @param {Feature} cluster The cluster feature.\n * @return {Style} Polygon style for the convex hull of the cluster.\n */\nfunction clusterHullStyle(cluster) {\n  if (cluster !== hoverFeature) {\n    return;\n  }\n  const originalFeatures = cluster.get('features');\n  const points = originalFeatures.map((feature) =>\n    feature.getGeometry().getCoordinates()\n  );\n  return new Style({\n    geometry: new Polygon([monotoneChainConvexHull(points)]),\n    fill: convexHullFill,\n    stroke: convexHullStroke,\n  });\n}\n\nfunction clusterStyle(feature) {\n  const size = feature.get('features').length;\n  if (size > 1) {\n    return [\n      new Style({\n        image: outerCircle,\n      }),\n      new Style({\n        image: innerCircle,\n        text: new Text({\n          text: size.toString(),\n          fill: textFill,\n          stroke: textStroke,\n        }),\n      }),\n    ];\n  } else {\n    const originalFeature = feature.get('features')[0];\n    return clusterMemberStyle(originalFeature);\n  }\n}\n\nconst vectorSource = new VectorSource({\n  format: new GeoJSON(),\n  url: 'data/geojson/photovoltaic.json',\n});\n\nconst clusterSource = new Cluster({\n  attributions:\n    'Data: <a href=\"https://www.data.gv.at/auftritte/?organisation=stadt-wien\">Stadt Wien</a>',\n  distance: 35,\n  source: vectorSource,\n});\n\n// Layer displaying the convex hull of the hovered cluster.\nconst clusterHulls = new VectorLayer({\n  source: clusterSource,\n  style: clusterHullStyle,\n});\n\n// Layer displaying the clusters and individual features.\nconst clusters = new VectorLayer({\n  source: clusterSource,\n  style: clusterStyle,\n});\n\n// Layer displaying the expanded view of overlapping cluster members.\nconst clusterCircles = new VectorLayer({\n  source: clusterSource,\n  style: clusterCircleStyle,\n});\n\nconst raster = new TileLayer({\n  source: new XYZ({\n    attributions:\n      'Base map: <a target=\"_blank\" href=\"https://basemap.at/\">basemap.at</a>',\n    url: 'https://maps{1-4}.wien.gv.at/basemap/bmapgrau/normal/google3857/{z}/{y}/{x}.png',\n  }),\n});\n\nconst map = new Map({\n  layers: [raster, clusterHulls, clusters, clusterCircles],\n  target: 'map',\n  view: new View({\n    center: [0, 0],\n    zoom: 2,\n    maxZoom: 19,\n    extent: [\n      ...fromLonLat([16.1793, 48.1124]),\n      ...fromLonLat([16.5559, 48.313]),\n    ],\n    showFullExtent: true,\n  }),\n});\n\nmap.on('pointermove', (event) => {\n  clusters.getFeatures(event.pixel).then((features) => {\n    if (features[0] !== hoverFeature) {\n      // Display the convex hull on hover.\n      hoverFeature = features[0];\n      clusterHulls.setStyle(clusterHullStyle);\n      // Change the cursor style to indicate that the cluster is clickable.\n      map.getTargetElement().style.cursor =\n        hoverFeature && hoverFeature.get('features').length > 1\n          ? 'pointer'\n          : '';\n    }\n  });\n});\n\nmap.on('click', (event) => {\n  clusters.getFeatures(event.pixel).then((features) => {\n    if (features.length > 0) {\n      const clusterMembers = features[0].get('features');\n      if (clusterMembers.length > 1) {\n        // Calculate the extent of the cluster members.\n        const extent = createEmpty();\n        clusterMembers.forEach((feature) =>\n          extend(extent, feature.getGeometry().getExtent())\n        );\n        const view = map.getView();\n        const resolution = map.getView().getResolution();\n        if (\n          view.getZoom() === view.getMaxZoom() ||\n          (getWidth(extent) < resolution && getWidth(extent) < resolution)\n        ) {\n          // Show an expanded view of the cluster members.\n          clickFeature = features[0];\n          clickResolution = resolution;\n          clusterCircles.setStyle(clusterCircleStyle);\n        } else {\n          // Zoom to the extent of the cluster members.\n          view.fit(extent, {duration: 500, padding: [50, 50, 50, 50]});\n        }\n      }\n    }\n  });\n});\n"],"names":["circleStartAngle","Math","PI","convexHullFill","color","convexHullStroke","width","outerCircleFill","innerCircleFill","textFill","textStroke","innerCircle","radius","fill","outerCircle","darkIcon","src","lightIcon","clusterMemberStyle","clusterMember","geometry","getGeometry","image","get","clickFeature","clickResolution","hoverFeature","clusterCircleStyle","cluster","resolution","clusterMembers","centerCoordinates","getCoordinates","count","clusterCenter","legLength","circleDistanceMultiplier","angleStep","res","angle","max","i","push","cos","sin","generatePointsCircle","length","reduce","styles","coordinates","point","line","unshift","stroke","getProperties","clusterHullStyle","points","map","feature","monotoneChainConvexHull","vectorSource","format","url","clusterSource","attributions","distance","source","clusterHulls","style","clusters","size","text","toString","clusterCircles","raster","layers","target","view","center","zoom","maxZoom","extent","showFullExtent","on","event","getFeatures","pixel","then","features","setStyle","getTargetElement","cursor","forEach","getExtent","getView","getResolution","getZoom","getMaxZoom","fit","duration","padding"],"sourceRoot":""}