{"version":3,"file":"webgl-vector-layer.js","mappings":"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","sources":["webpack:///../src/ol/render/webgl/BatchRenderer.js","webpack:///../src/ol/render/webgl/LineStringBatchRenderer.js","webpack:///../src/ol/render/webgl/MixedGeometryBatch.js","webpack:///../src/ol/render/webgl/PointBatchRenderer.js","webpack:///../src/ol/render/webgl/PolygonBatchRenderer.js","webpack:///../src/ol/renderer/webgl/shaders.js","webpack:///../src/ol/renderer/webgl/VectorLayer.js","webpack:///./webgl-vector-layer.js"],"sourcesContent":["/**\n * @module ol/render/webgl/BatchRenderer\n */\nimport {WebGLWorkerMessageType} from './constants.js';\nimport {abstract} from '../../util.js';\nimport {\n  create as createTransform,\n  makeInverse as makeInverseTransform,\n  multiply as multiplyTransform,\n  translate as translateTransform,\n} from '../../transform.js';\n\n/**\n * @typedef {Object} CustomAttribute A description of a custom attribute to be passed on to the GPU, with a value different\n * for each feature.\n * @property {string} name Attribute name.\n * @property {function(import(\"../../Feature\").default):number} callback This callback computes the numerical value of the\n * attribute for a given feature.\n */\n\nlet workerMessageCounter = 0;\n\n/**\n * @classdesc Abstract class for batch renderers.\n * Batch renderers are meant to render the geometries contained in a {@link module:ol/render/webgl/GeometryBatch}\n * instance. They are responsible for generating render instructions and transforming them into WebGL buffers.\n */\nclass AbstractBatchRenderer {\n  /**\n   * @param {import(\"../../webgl/Helper.js\").default} helper WebGL helper instance\n   * @param {Worker} worker WebGL worker instance\n   * @param {string} vertexShader Vertex shader\n   * @param {string} fragmentShader Fragment shader\n   * @param {Array<CustomAttribute>} customAttributes List of custom attributes\n   */\n  constructor(helper, worker, vertexShader, fragmentShader, customAttributes) {\n    /**\n     * @type {import(\"../../webgl/Helper.js\").default}\n     * @private\n     */\n    this.helper_ = helper;\n\n    /**\n     * @type {Worker}\n     * @private\n     */\n    this.worker_ = worker;\n\n    /**\n     * @type {WebGLProgram}\n     * @private\n     */\n    this.program_ = this.helper_.getProgram(fragmentShader, vertexShader);\n\n    /**\n     * A list of attributes used by the renderer.\n     * @type {Array<import('../../webgl/Helper.js').AttributeDescription>}\n     * @protected\n     */\n    this.attributes = [];\n\n    /**\n     * @type {Array<CustomAttribute>}\n     * @protected\n     */\n    this.customAttributes = customAttributes;\n  }\n\n  /**\n   * Rebuild rendering instructions and webgl buffers based on the provided frame state\n   * Note: this is a costly operation.\n   * @param {import(\"./MixedGeometryBatch.js\").GeometryBatch} batch Geometry batch\n   * @param {import(\"../../Map\").FrameState} frameState Frame state.\n   * @param {import(\"../../geom/Geometry.js\").Type} geometryType Geometry type\n   * @param {function(): void} callback Function called once the render buffers are updated\n   */\n  rebuild(batch, frameState, geometryType, callback) {\n    // store transform for rendering instructions\n    batch.renderInstructionsTransform = this.helper_.makeProjectionTransform(\n      frameState,\n      createTransform()\n    );\n    this.generateRenderInstructions(batch);\n    this.generateBuffers_(batch, geometryType, callback);\n  }\n\n  /**\n   * Render the geometries in the batch. This will also update the current transform used for rendering according to\n   * the invert transform of the webgl buffers\n   * @param {import(\"./MixedGeometryBatch.js\").GeometryBatch} batch Geometry batch\n   * @param {import(\"../../transform.js\").Transform} currentTransform Transform\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} offsetX X offset\n   */\n  render(batch, currentTransform, frameState, offsetX) {\n    // multiply the current projection transform with the invert of the one used to fill buffers\n    this.helper_.makeProjectionTransform(frameState, currentTransform);\n    translateTransform(currentTransform, offsetX, 0);\n    multiplyTransform(currentTransform, batch.invertVerticesBufferTransform);\n\n    // enable program, buffers and attributes\n    this.helper_.useProgram(this.program_, frameState);\n    this.helper_.bindBuffer(batch.verticesBuffer);\n    this.helper_.bindBuffer(batch.indicesBuffer);\n    this.helper_.enableAttributes(this.attributes);\n\n    const renderCount = batch.indicesBuffer.getSize();\n    this.helper_.drawElements(0, renderCount);\n  }\n\n  /**\n   * Rebuild rendering instructions based on the provided frame state\n   * This is specific to the geometry type and has to be implemented by subclasses.\n   * @param {import(\"./MixedGeometryBatch.js\").GeometryBatch} batch Geometry batch\n   * @protected\n   */\n  generateRenderInstructions(batch) {\n    abstract();\n  }\n\n  /**\n   * Rebuild internal webgl buffers for rendering based on the current rendering instructions;\n   * This is asynchronous: webgl buffers wil _not_ be updated right away\n   * @param {import(\"./MixedGeometryBatch.js\").GeometryBatch} batch Geometry batch\n   * @param {import(\"../../geom/Geometry.js\").Type} geometryType Geometry type\n   * @param {function(): void} callback Function called once the render buffers are updated\n   * @private\n   */\n  generateBuffers_(batch, geometryType, callback) {\n    const messageId = workerMessageCounter++;\n\n    let messageType;\n    switch (geometryType) {\n      case 'Polygon':\n        messageType = WebGLWorkerMessageType.GENERATE_POLYGON_BUFFERS;\n        break;\n      case 'Point':\n        messageType = WebGLWorkerMessageType.GENERATE_POINT_BUFFERS;\n        break;\n      case 'LineString':\n        messageType = WebGLWorkerMessageType.GENERATE_LINE_STRING_BUFFERS;\n        break;\n      default:\n      // pass\n    }\n\n    /** @type {import('./constants.js').WebGLWorkerGenerateBuffersMessage} */\n    const message = {\n      id: messageId,\n      type: messageType,\n      renderInstructions: batch.renderInstructions.buffer,\n      renderInstructionsTransform: batch.renderInstructionsTransform,\n      customAttributesCount: this.customAttributes.length,\n    };\n    this.worker_.postMessage(message, [batch.renderInstructions.buffer]);\n\n    // leave ownership of render instructions\n    batch.renderInstructions = null;\n\n    const handleMessage =\n      /**\n       * @param {*} event Event.\n       * @this {AbstractBatchRenderer}\n       */\n      function (event) {\n        const received = event.data;\n\n        // this is not the response to our request: skip\n        if (received.id !== messageId) {\n          return;\n        }\n\n        // we've received our response: stop listening\n        this.worker_.removeEventListener('message', handleMessage);\n\n        // store transform & invert transform for webgl buffers\n        batch.verticesBufferTransform = received.renderInstructionsTransform;\n        makeInverseTransform(\n          batch.invertVerticesBufferTransform,\n          batch.verticesBufferTransform\n        );\n\n        // copy & flush received buffers to GPU\n        batch.verticesBuffer.fromArrayBuffer(received.vertexBuffer);\n        this.helper_.flushBufferData(batch.verticesBuffer);\n        batch.indicesBuffer.fromArrayBuffer(received.indexBuffer);\n        this.helper_.flushBufferData(batch.indicesBuffer);\n\n        // take back ownership of the render instructions for further use\n        batch.renderInstructions = new Float32Array(\n          received.renderInstructions\n        );\n\n        callback();\n      }.bind(this);\n\n    this.worker_.addEventListener('message', handleMessage);\n  }\n}\n\nexport default AbstractBatchRenderer;\n","/**\n * @module ol/render/webgl/LineStringBatchRenderer\n */\nimport AbstractBatchRenderer from './BatchRenderer.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {transform2D} from '../../geom/flat/transform.js';\n\n/**\n * Names of attributes made available to the vertex shader.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport const Attributes = {\n  SEGMENT_START: 'a_segmentStart',\n  SEGMENT_END: 'a_segmentEnd',\n  PARAMETERS: 'a_parameters',\n};\n\nclass LineStringBatchRenderer extends AbstractBatchRenderer {\n  /**\n   * @param {import(\"../../webgl/Helper.js\").default} helper WebGL helper instance\n   * @param {Worker} worker WebGL worker instance\n   * @param {string} vertexShader Vertex shader\n   * @param {string} fragmentShader Fragment shader\n   * @param {Array<import('./BatchRenderer.js').CustomAttribute>} customAttributes List of custom attributes\n   */\n  constructor(helper, worker, vertexShader, fragmentShader, customAttributes) {\n    super(helper, worker, vertexShader, fragmentShader, customAttributes);\n\n    // vertices for lines must hold both a position (x,y) and an offset (dx,dy)\n    this.attributes = [\n      {\n        name: Attributes.SEGMENT_START,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.SEGMENT_END,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.PARAMETERS,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(\n      customAttributes.map(function (attribute) {\n        return {\n          name: 'a_' + attribute.name,\n          size: 1,\n          type: AttributeType.FLOAT,\n        };\n      })\n    );\n  }\n\n  /**\n   * Render instructions for lines are structured like so:\n   * [ customAttr0, ... , customAttrN, numberOfVertices0, x0, y0, ... , xN, yN, numberOfVertices1, ... ]\n   * @param {import(\"./MixedGeometryBatch.js\").LineStringGeometryBatch} batch Linestring geometry batch\n   * @override\n   */\n  generateRenderInstructions(batch) {\n    // here we anticipate the amount of render instructions for lines:\n    // 2 instructions per vertex for position (x and y)\n    // + 1 instruction per line per custom attributes\n    // + 1 instruction per line (for vertices count)\n    const totalInstructionsCount =\n      2 * batch.verticesCount +\n      (1 + this.customAttributes.length) * batch.geometriesCount;\n    if (\n      !batch.renderInstructions ||\n      batch.renderInstructions.length !== totalInstructionsCount\n    ) {\n      batch.renderInstructions = new Float32Array(totalInstructionsCount);\n    }\n\n    // loop on features to fill the render instructions\n    let batchEntry;\n    const flatCoords = [];\n    let renderIndex = 0;\n    let value;\n    for (const featureUid in batch.entries) {\n      batchEntry = batch.entries[featureUid];\n      for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n        flatCoords.length = batchEntry.flatCoordss[i].length;\n        transform2D(\n          batchEntry.flatCoordss[i],\n          0,\n          flatCoords.length,\n          2,\n          batch.renderInstructionsTransform,\n          flatCoords\n        );\n\n        // custom attributes\n        for (let k = 0, kk = this.customAttributes.length; k < kk; k++) {\n          value = this.customAttributes[k].callback(batchEntry.feature);\n          batch.renderInstructions[renderIndex++] = value;\n        }\n\n        // vertices count\n        batch.renderInstructions[renderIndex++] = flatCoords.length / 2;\n\n        // looping on points for positions\n        for (let j = 0, jj = flatCoords.length; j < jj; j += 2) {\n          batch.renderInstructions[renderIndex++] = flatCoords[j];\n          batch.renderInstructions[renderIndex++] = flatCoords[j + 1];\n        }\n      }\n    }\n  }\n}\n\nexport default LineStringBatchRenderer;\n","/**\n * @module ol/render/webgl/MixedGeometryBatch\n */\nimport WebGLArrayBuffer from '../../webgl/Buffer.js';\nimport {ARRAY_BUFFER, DYNAMIC_DRAW, ELEMENT_ARRAY_BUFFER} from '../../webgl.js';\nimport {create as createTransform} from '../../transform.js';\nimport {getUid} from '../../util.js';\n\n/**\n * @typedef {Object} GeometryBatchItem Object that holds a reference to a feature as well as the raw coordinates of its various geometries\n * @property {import(\"../../Feature\").default} feature Feature\n * @property {Array<Array<number>>} flatCoordss Array of flat coordinates arrays, one for each geometry related to the feature\n * @property {number} [verticesCount] Only defined for linestring and polygon batches\n * @property {number} [ringsCount] Only defined for polygon batches\n * @property {Array<Array<number>>} [ringsVerticesCounts] Array of vertices counts in each ring for each geometry; only defined for polygons batches\n */\n\n/**\n * @typedef {PointGeometryBatch|LineStringGeometryBatch|PolygonGeometryBatch} GeometryBatch\n */\n\n/**\n * @typedef {Object} PolygonGeometryBatch A geometry batch specific to polygons\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {Float32Array} renderInstructions Render instructions for polygons are structured like so:\n * [ numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, customAttr0, ..., xN, yN, customAttrN, numberOfRings,... ]\n * @property {WebGLArrayBuffer} verticesBuffer Vertices WebGL buffer\n * @property {WebGLArrayBuffer} indicesBuffer Indices WebGL buffer\n * @property {import(\"../../transform.js\").Transform} renderInstructionsTransform Converts world space coordinates to screen space; applies to the rendering instructions\n * @property {import(\"../../transform.js\").Transform} verticesBufferTransform Converts world space coordinates to screen space; applies to the webgl vertices buffer\n * @property {import(\"../../transform.js\").Transform} invertVerticesBufferTransform Screen space to world space; applies to the webgl vertices buffer\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n * @property {number} ringsCount How many outer and inner rings in this batch.\n */\n\n/**\n * @typedef {Object} LineStringGeometryBatch A geometry batch specific to lines\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {Float32Array} renderInstructions Render instructions for polygons are structured like so:\n * [ numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, customAttr0, ..., xN, yN, customAttrN, numberOfRings,... ]\n * @property {WebGLArrayBuffer} verticesBuffer Vertices WebGL buffer\n * @property {WebGLArrayBuffer} indicesBuffer Indices WebGL buffer\n * @property {import(\"../../transform.js\").Transform} renderInstructionsTransform Converts world space coordinates to screen space; applies to the rendering instructions\n * @property {import(\"../../transform.js\").Transform} verticesBufferTransform Converts world space coordinates to screen space; applies to the webgl vertices buffer\n * @property {import(\"../../transform.js\").Transform} invertVerticesBufferTransform Screen space to world space; applies to the webgl vertices buffer\n * @property {number} verticesCount Amount of vertices from geometries in the batch.\n */\n\n/**\n * @typedef {Object} PointGeometryBatch A geometry batch specific to points\n * @property {Object<string, GeometryBatchItem>} entries Dictionary of all entries in the batch with associated computed values.\n * One entry corresponds to one feature. Key is feature uid.\n * @property {number} geometriesCount Amount of geometries in the batch.\n * @property {Float32Array} renderInstructions Render instructions for polygons are structured like so:\n * [ numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, customAttr0, ..., xN, yN, customAttrN, numberOfRings,... ]\n * @property {WebGLArrayBuffer} verticesBuffer Vertices WebGL buffer\n * @property {WebGLArrayBuffer} indicesBuffer Indices WebGL buffer\n * @property {import(\"../../transform.js\").Transform} renderInstructionsTransform Converts world space coordinates to screen space; applies to the rendering instructions\n * @property {import(\"../../transform.js\").Transform} verticesBufferTransform Converts world space coordinates to screen space; applies to the webgl vertices buffer\n * @property {import(\"../../transform.js\").Transform} invertVerticesBufferTransform Screen space to world space; applies to the webgl vertices buffer\n */\n\n/**\n * @classdesc This class is used to group several geometries of various types together for faster rendering.\n * Three inner batches are maintained for polygons, lines and points. Each time a feature is added, changed or removed\n * from the batch, these inner batches are modified accordingly in order to keep them up-to-date.\n *\n * A feature can be present in several inner batches, for example a polygon geometry will be present in the polygon batch\n * and its linar rings will be present in the line batch. Multi geometries are also broken down into individual geometries\n * and added to the corresponding batches in a recursive manner.\n *\n * Corresponding {@link module:ol/render/webgl/BatchRenderer} instances are then used to generate the render instructions\n * and WebGL buffers (vertices and indices) for each inner batches; render instructions are stored on the inner batches,\n * alongside the transform used to convert world coords to screen coords at the time these instructions were generated.\n * The resulting WebGL buffers are stored on the batches as well.\n *\n * An important aspect of geometry batches is that there is no guarantee that render instructions and WebGL buffers\n * are synchronized, i.e. render instructions can describe a new state while WebGL buffers might not have been written yet.\n * This is why two world-to-screen transforms are stored on each batch: one for the render instructions and one for\n * the WebGL buffers.\n */\nclass MixedGeometryBatch {\n  constructor() {\n    /**\n     * @type {PolygonGeometryBatch}\n     */\n    this.polygonBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0,\n      ringsCount: 0,\n      renderInstructions: new Float32Array(0),\n      verticesBuffer: new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW),\n      indicesBuffer: new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW),\n      renderInstructionsTransform: createTransform(),\n      verticesBufferTransform: createTransform(),\n      invertVerticesBufferTransform: createTransform(),\n    };\n\n    /**\n     * @type {PointGeometryBatch}\n     */\n    this.pointBatch = {\n      entries: {},\n      geometriesCount: 0,\n      renderInstructions: new Float32Array(0),\n      verticesBuffer: new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW),\n      indicesBuffer: new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW),\n      renderInstructionsTransform: createTransform(),\n      verticesBufferTransform: createTransform(),\n      invertVerticesBufferTransform: createTransform(),\n    };\n\n    /**\n     * @type {LineStringGeometryBatch}\n     */\n    this.lineStringBatch = {\n      entries: {},\n      geometriesCount: 0,\n      verticesCount: 0,\n      renderInstructions: new Float32Array(0),\n      verticesBuffer: new WebGLArrayBuffer(ARRAY_BUFFER, DYNAMIC_DRAW),\n      indicesBuffer: new WebGLArrayBuffer(ELEMENT_ARRAY_BUFFER, DYNAMIC_DRAW),\n      renderInstructionsTransform: createTransform(),\n      verticesBufferTransform: createTransform(),\n      invertVerticesBufferTransform: createTransform(),\n    };\n  }\n\n  /**\n   * @param {Array<import(\"../../Feature\").default>} features Array of features to add to the batch\n   */\n  addFeatures(features) {\n    for (let i = 0; i < features.length; i++) {\n      this.addFeature(features[i]);\n    }\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature to add to the batch\n   */\n  addFeature(feature) {\n    const geometry = feature.getGeometry();\n    if (!geometry) {\n      return;\n    }\n    this.addGeometry_(geometry, feature);\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   * @return {GeometryBatchItem} Batch item added (or existing one)\n   * @private\n   */\n  addFeatureEntryInPointBatch_(feature) {\n    const uid = getUid(feature);\n    if (!(uid in this.pointBatch.entries)) {\n      this.pointBatch.entries[uid] = {\n        feature: feature,\n        flatCoordss: [],\n      };\n    }\n    return this.pointBatch.entries[uid];\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   * @return {GeometryBatchItem} Batch item added (or existing one)\n   * @private\n   */\n  addFeatureEntryInLineStringBatch_(feature) {\n    const uid = getUid(feature);\n    if (!(uid in this.lineStringBatch.entries)) {\n      this.lineStringBatch.entries[uid] = {\n        feature: feature,\n        flatCoordss: [],\n        verticesCount: 0,\n      };\n    }\n    return this.lineStringBatch.entries[uid];\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   * @return {GeometryBatchItem} Batch item added (or existing one)\n   * @private\n   */\n  addFeatureEntryInPolygonBatch_(feature) {\n    const uid = getUid(feature);\n    if (!(uid in this.polygonBatch.entries)) {\n      this.polygonBatch.entries[uid] = {\n        feature: feature,\n        flatCoordss: [],\n        verticesCount: 0,\n        ringsCount: 0,\n        ringsVerticesCounts: [],\n      };\n    }\n    return this.polygonBatch.entries[uid];\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   * @private\n   */\n  clearFeatureEntryInPointBatch_(feature) {\n    const entry = this.pointBatch.entries[getUid(feature)];\n    if (!entry) {\n      return;\n    }\n    this.pointBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.pointBatch.entries[getUid(feature)];\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   * @private\n   */\n  clearFeatureEntryInLineStringBatch_(feature) {\n    const entry = this.lineStringBatch.entries[getUid(feature)];\n    if (!entry) {\n      return;\n    }\n    this.lineStringBatch.verticesCount -= entry.verticesCount;\n    this.lineStringBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.lineStringBatch.entries[getUid(feature)];\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   * @private\n   */\n  clearFeatureEntryInPolygonBatch_(feature) {\n    const entry = this.polygonBatch.entries[getUid(feature)];\n    if (!entry) {\n      return;\n    }\n    this.polygonBatch.verticesCount -= entry.verticesCount;\n    this.polygonBatch.ringsCount -= entry.ringsCount;\n    this.polygonBatch.geometriesCount -= entry.flatCoordss.length;\n    delete this.polygonBatch.entries[getUid(feature)];\n  }\n\n  /**\n   * @param {import(\"../../geom\").Geometry} geometry Geometry\n   * @param {import(\"../../Feature\").default} feature Feature\n   * @private\n   */\n  addGeometry_(geometry, feature) {\n    const type = geometry.getType();\n    let flatCoords;\n    let verticesCount;\n    let batchEntry;\n    switch (type) {\n      case 'GeometryCollection':\n        /** @type {import(\"../../geom\").GeometryCollection} */ (geometry)\n          .getGeometries()\n          .map((geom) => this.addGeometry_(geom, feature));\n        break;\n      case 'MultiPolygon':\n        /** @type {import(\"../../geom\").MultiPolygon} */ (geometry)\n          .getPolygons()\n          .map((polygon) => this.addGeometry_(polygon, feature));\n        break;\n      case 'MultiLineString':\n        /** @type {import(\"../../geom\").MultiLineString} */ (geometry)\n          .getLineStrings()\n          .map((line) => this.addGeometry_(line, feature));\n        break;\n      case 'MultiPoint':\n        /** @type {import(\"../../geom\").MultiPoint} */ (geometry)\n          .getPoints()\n          .map((point) => this.addGeometry_(point, feature));\n        break;\n      case 'Polygon':\n        const polygonGeom = /** @type {import(\"../../geom\").Polygon} */ (\n          geometry\n        );\n        batchEntry = this.addFeatureEntryInPolygonBatch_(feature);\n        flatCoords = polygonGeom.getFlatCoordinates();\n        verticesCount = flatCoords.length / 2;\n        const ringsCount = polygonGeom.getLinearRingCount();\n        const ringsVerticesCount = polygonGeom\n          .getEnds()\n          .map((end, ind, arr) =>\n            ind > 0 ? (end - arr[ind - 1]) / 2 : end / 2\n          );\n        this.polygonBatch.verticesCount += verticesCount;\n        this.polygonBatch.ringsCount += ringsCount;\n        this.polygonBatch.geometriesCount++;\n        batchEntry.flatCoordss.push(flatCoords);\n        batchEntry.ringsVerticesCounts.push(ringsVerticesCount);\n        batchEntry.verticesCount += verticesCount;\n        batchEntry.ringsCount += ringsCount;\n        polygonGeom\n          .getLinearRings()\n          .map((ring) => this.addGeometry_(ring, feature));\n        break;\n      case 'Point':\n        const pointGeom = /** @type {import(\"../../geom\").Point} */ (geometry);\n        batchEntry = this.addFeatureEntryInPointBatch_(feature);\n        flatCoords = pointGeom.getFlatCoordinates();\n        this.pointBatch.geometriesCount++;\n        batchEntry.flatCoordss.push(flatCoords);\n        break;\n      case 'LineString':\n      case 'LinearRing':\n        const lineGeom = /** @type {import(\"../../geom\").LineString} */ (\n          geometry\n        );\n        batchEntry = this.addFeatureEntryInLineStringBatch_(feature);\n        flatCoords = lineGeom.getFlatCoordinates();\n        verticesCount = flatCoords.length / 2;\n        this.lineStringBatch.verticesCount += verticesCount;\n        this.lineStringBatch.geometriesCount++;\n        batchEntry.flatCoordss.push(flatCoords);\n        batchEntry.verticesCount += verticesCount;\n        break;\n      default:\n      // pass\n    }\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   */\n  changeFeature(feature) {\n    this.clearFeatureEntryInPointBatch_(feature);\n    this.clearFeatureEntryInPolygonBatch_(feature);\n    this.clearFeatureEntryInLineStringBatch_(feature);\n    const geometry = feature.getGeometry();\n    if (!geometry) {\n      return;\n    }\n    this.addGeometry_(geometry, feature);\n  }\n\n  /**\n   * @param {import(\"../../Feature\").default} feature Feature\n   */\n  removeFeature(feature) {\n    this.clearFeatureEntryInPointBatch_(feature);\n    this.clearFeatureEntryInPolygonBatch_(feature);\n    this.clearFeatureEntryInLineStringBatch_(feature);\n  }\n\n  clear() {\n    this.polygonBatch.entries = {};\n    this.polygonBatch.geometriesCount = 0;\n    this.polygonBatch.verticesCount = 0;\n    this.polygonBatch.ringsCount = 0;\n    this.lineStringBatch.entries = {};\n    this.lineStringBatch.geometriesCount = 0;\n    this.lineStringBatch.verticesCount = 0;\n    this.pointBatch.entries = {};\n    this.pointBatch.geometriesCount = 0;\n  }\n}\n\nexport default MixedGeometryBatch;\n","/**\n * @module ol/render/webgl/PointBatchRenderer\n */\n\nimport AbstractBatchRenderer from './BatchRenderer.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {apply as applyTransform} from '../../transform.js';\n\n/**\n * Names of attributes made available to the vertex shader.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport const Attributes = {\n  POSITION: 'a_position',\n  INDEX: 'a_index',\n};\n\nclass PointBatchRenderer extends AbstractBatchRenderer {\n  /**\n   * @param {import(\"../../webgl/Helper.js\").default} helper WebGL helper instance\n   * @param {Worker} worker WebGL worker instance\n   * @param {string} vertexShader Vertex shader\n   * @param {string} fragmentShader Fragment shader\n   * @param {Array<import('./BatchRenderer.js').CustomAttribute>} customAttributes List of custom attributes\n   */\n  constructor(helper, worker, vertexShader, fragmentShader, customAttributes) {\n    super(helper, worker, vertexShader, fragmentShader, customAttributes);\n\n    // vertices for point must hold both a position (x,y) and an index (their position in the quad)\n    this.attributes = [\n      {\n        name: Attributes.POSITION,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n      {\n        name: Attributes.INDEX,\n        size: 1,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(\n      customAttributes.map(function (attribute) {\n        return {\n          name: 'a_' + attribute.name,\n          size: 1,\n          type: AttributeType.FLOAT,\n        };\n      })\n    );\n  }\n\n  /**\n   * Render instructions for lines are structured like so:\n   * [ x0, y0, customAttr0, ... , xN, yN, customAttrN ]\n   * @param {import(\"./MixedGeometryBatch.js\").PointGeometryBatch} batch Point geometry batch\n   * @override\n   */\n  generateRenderInstructions(batch) {\n    // here we anticipate the amount of render instructions for points:\n    // 2 instructions per vertex for position (x and y)\n    // + 1 instruction per vertex per custom attributes\n    const totalInstructionsCount =\n      (2 + this.customAttributes.length) * batch.geometriesCount;\n    if (\n      !batch.renderInstructions ||\n      batch.renderInstructions.length !== totalInstructionsCount\n    ) {\n      batch.renderInstructions = new Float32Array(totalInstructionsCount);\n    }\n\n    // loop on features to fill the render instructions\n    let batchEntry;\n    const tmpCoords = [];\n    let renderIndex = 0;\n    let value;\n    for (const featureUid in batch.entries) {\n      batchEntry = batch.entries[featureUid];\n      for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n        tmpCoords[0] = batchEntry.flatCoordss[i][0];\n        tmpCoords[1] = batchEntry.flatCoordss[i][1];\n        applyTransform(batch.renderInstructionsTransform, tmpCoords);\n\n        batch.renderInstructions[renderIndex++] = tmpCoords[0];\n        batch.renderInstructions[renderIndex++] = tmpCoords[1];\n\n        // pushing custom attributes\n        for (let j = 0, jj = this.customAttributes.length; j < jj; j++) {\n          value = this.customAttributes[j].callback(batchEntry.feature);\n          batch.renderInstructions[renderIndex++] = value;\n        }\n      }\n    }\n  }\n}\n\nexport default PointBatchRenderer;\n","/**\n * @module ol/render/webgl/PolygonBatchRenderer\n */\nimport AbstractBatchRenderer from './BatchRenderer.js';\nimport {AttributeType} from '../../webgl/Helper.js';\nimport {transform2D} from '../../geom/flat/transform.js';\n\n/**\n * Names of attributes made available to the vertex shader.\n * Please note: changing these *will* break custom shaders!\n * @enum {string}\n */\nexport const Attributes = {\n  POSITION: 'a_position',\n};\n\nclass PolygonBatchRenderer extends AbstractBatchRenderer {\n  /**\n   * @param {import(\"../../webgl/Helper.js\").default} helper WebGL helper instance\n   * @param {Worker} worker WebGL worker instance\n   * @param {string} vertexShader Vertex shader\n   * @param {string} fragmentShader Fragment shader\n   * @param {Array<import('./BatchRenderer.js').CustomAttribute>} customAttributes List of custom attributes\n   */\n  constructor(helper, worker, vertexShader, fragmentShader, customAttributes) {\n    super(helper, worker, vertexShader, fragmentShader, customAttributes);\n\n    // By default only a position attribute is required to render polygons\n    this.attributes = [\n      {\n        name: Attributes.POSITION,\n        size: 2,\n        type: AttributeType.FLOAT,\n      },\n    ].concat(\n      customAttributes.map(function (attribute) {\n        return {\n          name: 'a_' + attribute.name,\n          size: 1,\n          type: AttributeType.FLOAT,\n        };\n      })\n    );\n  }\n\n  /**\n   * Render instructions for polygons are structured like so:\n   * [ customAttr0, ..., customAttrN, numberOfRings, numberOfVerticesInRing0, ..., numberOfVerticesInRingN, x0, y0, ..., xN, yN, numberOfRings,... ]\n   * @param {import(\"./MixedGeometryBatch.js\").PolygonGeometryBatch} batch Polygon geometry batch\n   * @override\n   */\n  generateRenderInstructions(batch) {\n    // here we anticipate the amount of render instructions for polygons:\n    // 2 instructions per vertex for position (x and y)\n    // + 1 instruction per polygon per custom attributes\n    // + 1 instruction per polygon (for vertices count in polygon)\n    // + 1 instruction per ring (for vertices count in ring)\n    const totalInstructionsCount =\n      2 * batch.verticesCount +\n      (1 + this.customAttributes.length) * batch.geometriesCount +\n      batch.ringsCount;\n    if (\n      !batch.renderInstructions ||\n      batch.renderInstructions.length !== totalInstructionsCount\n    ) {\n      batch.renderInstructions = new Float32Array(totalInstructionsCount);\n    }\n\n    // loop on features to fill the render instructions\n    let batchEntry;\n    const flatCoords = [];\n    let renderIndex = 0;\n    let value;\n    for (const featureUid in batch.entries) {\n      batchEntry = batch.entries[featureUid];\n      for (let i = 0, ii = batchEntry.flatCoordss.length; i < ii; i++) {\n        flatCoords.length = batchEntry.flatCoordss[i].length;\n        transform2D(\n          batchEntry.flatCoordss[i],\n          0,\n          flatCoords.length,\n          2,\n          batch.renderInstructionsTransform,\n          flatCoords\n        );\n\n        // custom attributes\n        for (let k = 0, kk = this.customAttributes.length; k < kk; k++) {\n          value = this.customAttributes[k].callback(batchEntry.feature);\n          batch.renderInstructions[renderIndex++] = value;\n        }\n\n        // ring count\n        batch.renderInstructions[renderIndex++] =\n          batchEntry.ringsVerticesCounts[i].length;\n\n        // vertices count in each ring\n        for (\n          let j = 0, jj = batchEntry.ringsVerticesCounts[i].length;\n          j < jj;\n          j++\n        ) {\n          batch.renderInstructions[renderIndex++] =\n            batchEntry.ringsVerticesCounts[i][j];\n        }\n\n        // looping on points for positions\n        for (let j = 0, jj = flatCoords.length; j < jj; j += 2) {\n          batch.renderInstructions[renderIndex++] = flatCoords[j];\n          batch.renderInstructions[renderIndex++] = flatCoords[j + 1];\n        }\n      }\n    }\n  }\n}\n\nexport default PolygonBatchRenderer;\n","/**\n * @module ol/renderer/webgl/shaders\n */\nimport {asArray} from '../../color.js';\n\n/** @typedef {'color'|'opacity'|'width'} DefaultAttributes */\n\n/**\n * Packs red/green/blue channels of a color into a single float value; alpha is ignored.\n * This is how the color is expected to be computed.\n * @param {import(\"../../color.js\").Color|string} color Color as array of numbers or string\n * @return {number} Float value containing the color\n */\nexport function packColor(color) {\n  const array = asArray(color);\n  const r = array[0] * 256 * 256;\n  const g = array[1] * 256;\n  const b = array[2];\n  return r + g + b;\n}\n\nconst DECODE_COLOR_EXPRESSION = `vec3(\n  fract(floor(a_color / 256.0 / 256.0) / 256.0),\n  fract(floor(a_color / 256.0) / 256.0),\n  fract(a_color / 256.0)\n);`;\n\n/**\n * Default polygon vertex shader.\n * Relies on the color and opacity attributes.\n * @type {string}\n */\nexport const FILL_VERTEX_SHADER = `\n  precision mediump float;\n  uniform mat4 u_projectionMatrix;\n  attribute vec2 a_position;\n  attribute float a_color;\n  attribute float a_opacity;\n  varying vec3 v_color;\n  varying float v_opacity;\n\n  void main(void) {\n    gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n    v_color = ${DECODE_COLOR_EXPRESSION}\n    v_opacity = a_opacity;\n  }`;\n\n/**\n * Default polygon fragment shader.\n * @type {string}\n */\nexport const FILL_FRAGMENT_SHADER = `\n  precision mediump float;\n  varying vec3 v_color;\n  varying float v_opacity;\n\n  void main(void) {\n    gl_FragColor = vec4(v_color, 1.0) * v_opacity;\n  }`;\n\n/**\n * Default linestring vertex shader.\n * Relies on color, opacity and width attributes.\n * @type {string}\n */\nexport const STROKE_VERTEX_SHADER = `\n  precision mediump float;\n  uniform mat4 u_projectionMatrix;\n  uniform vec2 u_sizePx;\n  attribute vec2 a_segmentStart;\n  attribute vec2 a_segmentEnd;\n  attribute float a_parameters;\n  attribute float a_color;\n  attribute float a_opacity;\n  attribute float a_width;\n  varying vec2 v_segmentStart;\n  varying vec2 v_segmentEnd;\n  varying float v_angleStart;\n  varying float v_angleEnd;\n  varying vec3 v_color;\n  varying float v_opacity;\n  varying float v_width;\n\n  vec2 worldToPx(vec2 worldPos) {\n    vec4 screenPos = u_projectionMatrix * vec4(worldPos, 0.0, 1.0);\n    return (0.5 * screenPos.xy + 0.5) * u_sizePx;\n  }\n\n  vec4 pxToScreen(vec2 pxPos) {\n    vec2 screenPos = pxPos * 4.0 / u_sizePx;\n    return vec4(screenPos.xy, 0.0, 0.0);\n  }\n\n  vec2 getOffsetDirection(vec2 normalPx, vec2 tangentPx, float joinAngle) {\n    if (cos(joinAngle) > 0.93) return normalPx - tangentPx;\n    float halfAngle = joinAngle / 2.0;\n    vec2 angleBisectorNormal = vec2(\n      sin(halfAngle) * normalPx.x + cos(halfAngle) * normalPx.y,\n      -cos(halfAngle) * normalPx.x + sin(halfAngle) * normalPx.y\n    );\n    float length = 1.0 / sin(halfAngle);\n    return angleBisectorNormal * length;\n  }\n\n  void main(void) {\n    float anglePrecision = 1500.0;\n    float paramShift = 10000.0;\n    v_angleStart = fract(a_parameters / paramShift) * paramShift / anglePrecision;\n    v_angleEnd = fract(floor(a_parameters / paramShift + 0.5) / paramShift) * paramShift / anglePrecision;\n    float vertexNumber = floor(a_parameters / paramShift / paramShift + 0.0001);\n    vec2 tangentPx = worldToPx(a_segmentEnd) - worldToPx(a_segmentStart);\n    tangentPx = normalize(tangentPx);\n    vec2 normalPx = vec2(-tangentPx.y, tangentPx.x);\n    float normalDir = vertexNumber < 0.5 || (vertexNumber > 1.5 && vertexNumber < 2.5) ? 1.0 : -1.0;\n    float tangentDir = vertexNumber < 1.5 ? 1.0 : -1.0;\n    float angle = vertexNumber < 1.5 ? v_angleStart : v_angleEnd;\n    vec2 offsetPx = getOffsetDirection(normalPx * normalDir, tangentDir * tangentPx, angle) * a_width * 0.5;\n    vec2 position =  vertexNumber < 1.5 ? a_segmentStart : a_segmentEnd;\n    gl_Position = u_projectionMatrix * vec4(position, 0.0, 1.0) + pxToScreen(offsetPx);\n    v_segmentStart = worldToPx(a_segmentStart);\n    v_segmentEnd = worldToPx(a_segmentEnd);\n    v_color = ${DECODE_COLOR_EXPRESSION}\n    v_opacity = a_opacity;\n    v_width = a_width;\n  }`;\n\n/**\n * Default linestring fragment shader.\n * @type {string}\n */\nexport const STROKE_FRAGMENT_SHADER = `\n  precision mediump float;\n  uniform float u_pixelRatio;\n  varying vec2 v_segmentStart;\n  varying vec2 v_segmentEnd;\n  varying float v_angleStart;\n  varying float v_angleEnd;\n  varying vec3 v_color;\n  varying float v_opacity;\n  varying float v_width;\n\n  float segmentDistanceField(vec2 point, vec2 start, vec2 end, float radius) {\n    vec2 startToPoint = point - start;\n    vec2 startToEnd = end - start;\n    float ratio = clamp(dot(startToPoint, startToEnd) / dot(startToEnd, startToEnd), 0.0, 1.0);\n    float dist = length(startToPoint - ratio * startToEnd);\n    return 1.0 - smoothstep(radius - 1.0, radius, dist);\n  }\n\n  void main(void) {\n    vec2 v_currentPoint = gl_FragCoord.xy / u_pixelRatio;\n    gl_FragColor = vec4(v_color, 1.0) * v_opacity;\n    gl_FragColor *= segmentDistanceField(v_currentPoint, v_segmentStart, v_segmentEnd, v_width);\n  }`;\n\n/**\n * Default point vertex shader.\n * Relies on color and opacity attributes.\n * @type {string}\n */\nexport const POINT_VERTEX_SHADER = `\n  precision mediump float;\n  uniform mat4 u_projectionMatrix;\n  uniform mat4 u_offsetScaleMatrix;\n  attribute vec2 a_position;\n  attribute float a_index;\n  attribute float a_color;\n  attribute float a_opacity;\n  varying vec2 v_texCoord;\n  varying vec3 v_color;\n  varying float v_opacity;\n\n  void main(void) {\n    mat4 offsetMatrix = u_offsetScaleMatrix;\n    float size = 6.0;\n    float offsetX = a_index == 0.0 || a_index == 3.0 ? -size / 2.0 : size / 2.0;\n    float offsetY = a_index == 0.0 || a_index == 1.0 ? -size / 2.0 : size / 2.0;\n    vec4 offsets = offsetMatrix * vec4(offsetX, offsetY, 0.0, 0.0);\n    gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n    float u = a_index == 0.0 || a_index == 3.0 ? 0.0 : 1.0;\n    float v = a_index == 0.0 || a_index == 1.0 ? 0.0 : 1.0;\n    v_texCoord = vec2(u, v);\n    v_color = ${DECODE_COLOR_EXPRESSION}\n    v_opacity = a_opacity;\n  }`;\n\n/**\n * Default point fragment shader.\n * @type {string}\n */\nexport const POINT_FRAGMENT_SHADER = `\n  precision mediump float;\n  varying vec3 v_color;\n  varying float v_opacity;\n\n  void main(void) {\n      gl_FragColor = vec4(v_color, 1.0) * v_opacity;\n  }`;\n","/**\n * @module ol/renderer/webgl/VectorLayer\n */\nimport BaseVector from '../../layer/BaseVector.js';\nimport LineStringBatchRenderer from '../../render/webgl/LineStringBatchRenderer.js';\nimport MixedGeometryBatch from '../../render/webgl/MixedGeometryBatch.js';\nimport PointBatchRenderer from '../../render/webgl/PointBatchRenderer.js';\nimport PolygonBatchRenderer from '../../render/webgl/PolygonBatchRenderer.js';\nimport VectorEventType from '../../source/VectorEventType.js';\nimport ViewHint from '../../ViewHint.js';\nimport WebGLLayerRenderer from './Layer.js';\nimport {DefaultUniform} from '../../webgl/Helper.js';\nimport {\n  FILL_FRAGMENT_SHADER,\n  FILL_VERTEX_SHADER,\n  POINT_FRAGMENT_SHADER,\n  POINT_VERTEX_SHADER,\n  STROKE_FRAGMENT_SHADER,\n  STROKE_VERTEX_SHADER,\n  packColor,\n} from './shaders.js';\nimport {buffer, createEmpty, equals, getWidth} from '../../extent.js';\nimport {create as createTransform} from '../../transform.js';\nimport {create as createWebGLWorker} from '../../worker/webgl.js';\nimport {listen, unlistenByKey} from '../../events.js';\n\n/**\n * @typedef {function(import(\"../../Feature\").default, Object<string, *>):number} CustomAttributeCallback A callback computing\n * the value of a custom attribute (different for each feature) to be passed on to the GPU.\n * Properties are available as 2nd arg for quicker access.\n */\n\n/**\n * @typedef {Object} ShaderProgram An object containing both shaders (vertex and fragment) as well as the required attributes\n * @property {string} [vertexShader] Vertex shader source (using the default one if unspecified).\n * @property {string} [fragmentShader] Fragment shader source (using the default one if unspecified).\n * @property {Object<import(\"./shaders.js\").DefaultAttributes,CustomAttributeCallback>} attributes Custom attributes made available in the vertex shader.\n * Keys are the names of the attributes which are then accessible in the vertex shader using the `a_` prefix, e.g.: `a_opacity`.\n * Default shaders rely on the attributes in {@link module:ol/render/webgl/shaders~DefaultAttributes}.\n */\n\n/**\n * @typedef {Object} Options\n * @property {string} [className='ol-layer'] A CSS class name to set to the canvas element.\n * @property {ShaderProgram} [fill] Attributes and shaders for filling polygons.\n * @property {ShaderProgram} [stroke] Attributes and shaders for line strings and polygon strokes.\n * @property {ShaderProgram} [point] Attributes and shaders for points.\n * @property {Object<string,import(\"../../webgl/Helper\").UniformValue>} [uniforms] Uniform definitions.\n * @property {Array<import(\"./Layer\").PostProcessesOptions>} [postProcesses] Post-processes definitions\n */\n\n/**\n * @param {Object<import(\"./shaders.js\").DefaultAttributes,CustomAttributeCallback>} obj Lookup of attribute getters.\n * @return {Array<import(\"../../render/webgl/BatchRenderer\").CustomAttribute>} An array of attribute descriptors.\n */\nfunction toAttributesArray(obj) {\n  return Object.keys(obj).map((key) => ({name: key, callback: obj[key]}));\n}\n\n/**\n * @classdesc\n * Experimental WebGL vector renderer. Supports polygons, lines and points:\n *  * Polygons are broken down into triangles\n *  * Lines are rendered as strips of quads\n *  * Points are rendered as quads\n *\n * You need to provide vertex and fragment shaders as well as custom attributes for each type of geometry. All shaders\n * can access the uniforms in the {@link module:ol/webgl/Helper~DefaultUniform} enum.\n * The vertex shaders can access the following attributes depending on the geometry type:\n *  * For polygons: {@link module:ol/render/webgl/PolygonBatchRenderer~Attributes}\n *  * For line strings: {@link module:ol/render/webgl/LineStringBatchRenderer~Attributes}\n *  * For points: {@link module:ol/render/webgl/PointBatchRenderer~Attributes}\n *\n * Please note that the fragment shaders output should have premultiplied alpha, otherwise visual anomalies may occur.\n *\n * Note: this uses {@link module:ol/webgl/Helper~WebGLHelper} internally.\n */\nclass WebGLVectorLayerRenderer extends WebGLLayerRenderer {\n  /**\n   * @param {import(\"../../layer/Layer.js\").default} layer Layer.\n   * @param {Options} options Options.\n   */\n  constructor(layer, options) {\n    const uniforms = options.uniforms || {};\n    const projectionMatrixTransform = createTransform();\n    uniforms[DefaultUniform.PROJECTION_MATRIX] = projectionMatrixTransform;\n\n    super(layer, {\n      uniforms: uniforms,\n      postProcesses: options.postProcesses,\n    });\n\n    this.sourceRevision_ = -1;\n\n    this.previousExtent_ = createEmpty();\n\n    /**\n     * This transform is updated on every frame and is the composition of:\n     * - invert of the world->screen transform that was used when rebuilding buffers (see `this.renderTransform_`)\n     * - current world->screen transform\n     * @type {import(\"../../transform.js\").Transform}\n     * @private\n     */\n    this.currentTransform_ = projectionMatrixTransform;\n\n    const fillAttributes = {\n      color: function () {\n        return packColor('#ddd');\n      },\n      opacity: function () {\n        return 1;\n      },\n      ...(options.fill && options.fill.attributes),\n    };\n\n    const strokeAttributes = {\n      color: function () {\n        return packColor('#eee');\n      },\n      opacity: function () {\n        return 1;\n      },\n      width: function () {\n        return 1.5;\n      },\n      ...(options.stroke && options.stroke.attributes),\n    };\n\n    const pointAttributes = {\n      color: function () {\n        return packColor('#eee');\n      },\n      opacity: function () {\n        return 1;\n      },\n      ...(options.point && options.point.attributes),\n    };\n\n    this.fillVertexShader_ =\n      (options.fill && options.fill.vertexShader) || FILL_VERTEX_SHADER;\n    this.fillFragmentShader_ =\n      (options.fill && options.fill.fragmentShader) || FILL_FRAGMENT_SHADER;\n    this.fillAttributes_ = toAttributesArray(fillAttributes);\n\n    this.strokeVertexShader_ =\n      (options.stroke && options.stroke.vertexShader) || STROKE_VERTEX_SHADER;\n    this.strokeFragmentShader_ =\n      (options.stroke && options.stroke.fragmentShader) ||\n      STROKE_FRAGMENT_SHADER;\n    this.strokeAttributes_ = toAttributesArray(strokeAttributes);\n\n    this.pointVertexShader_ =\n      (options.point && options.point.vertexShader) || POINT_VERTEX_SHADER;\n    this.pointFragmentShader_ =\n      (options.point && options.point.fragmentShader) || POINT_FRAGMENT_SHADER;\n    this.pointAttributes_ = toAttributesArray(pointAttributes);\n\n    /**\n     * @private\n     */\n    this.worker_ = createWebGLWorker();\n\n    /**\n     * @private\n     */\n    this.batch_ = new MixedGeometryBatch();\n\n    const source = this.getLayer().getSource();\n    this.batch_.addFeatures(source.getFeatures());\n    this.sourceListenKeys_ = [\n      listen(\n        source,\n        VectorEventType.ADDFEATURE,\n        this.handleSourceFeatureAdded_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CHANGEFEATURE,\n        this.handleSourceFeatureChanged_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.REMOVEFEATURE,\n        this.handleSourceFeatureDelete_,\n        this\n      ),\n      listen(\n        source,\n        VectorEventType.CLEAR,\n        this.handleSourceFeatureClear_,\n        this\n      ),\n    ];\n  }\n\n  afterHelperCreated() {\n    this.polygonRenderer_ = new PolygonBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.fillVertexShader_,\n      this.fillFragmentShader_,\n      this.fillAttributes_\n    );\n    this.pointRenderer_ = new PointBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.pointVertexShader_,\n      this.pointFragmentShader_,\n      this.pointAttributes_\n    );\n    this.lineStringRenderer_ = new LineStringBatchRenderer(\n      this.helper,\n      this.worker_,\n      this.strokeVertexShader_,\n      this.strokeFragmentShader_,\n      this.strokeAttributes_\n    );\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureAdded_(event) {\n    const feature = event.feature;\n    this.batch_.addFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureChanged_(event) {\n    const feature = event.feature;\n    this.batch_.changeFeature(feature);\n  }\n\n  /**\n   * @param {import(\"../../source/Vector.js\").VectorSourceEvent} event Event.\n   * @private\n   */\n  handleSourceFeatureDelete_(event) {\n    const feature = event.feature;\n    this.batch_.removeFeature(feature);\n  }\n\n  /**\n   * @private\n   */\n  handleSourceFeatureClear_() {\n    this.batch_.clear();\n  }\n\n  /**\n   * Render the layer.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {HTMLElement} The rendered element.\n   */\n  renderFrame(frameState) {\n    const gl = this.helper.getGL();\n    this.preRender(gl, frameState);\n\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const projection = frameState.viewState.projection;\n    const multiWorld = vectorSource.getWrapX() && projection.canWrapX();\n    const projectionExtent = projection.getExtent();\n    const extent = frameState.extent;\n    const worldWidth = multiWorld ? getWidth(projectionExtent) : null;\n    const endWorld = multiWorld\n      ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1\n      : 1;\n    let world = multiWorld\n      ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth)\n      : 0;\n\n    do {\n      this.polygonRenderer_.render(\n        this.batch_.polygonBatch,\n        this.currentTransform_,\n        frameState,\n        world * worldWidth\n      );\n      this.lineStringRenderer_.render(\n        this.batch_.lineStringBatch,\n        this.currentTransform_,\n        frameState,\n        world * worldWidth\n      );\n      this.pointRenderer_.render(\n        this.batch_.pointBatch,\n        this.currentTransform_,\n        frameState,\n        world * worldWidth\n      );\n    } while (++world < endWorld);\n\n    this.helper.finalizeDraw(frameState);\n\n    const canvas = this.helper.getCanvas();\n    const layerState = frameState.layerStatesArray[frameState.layerIndex];\n    const opacity = layerState.opacity;\n    if (opacity !== parseFloat(canvas.style.opacity)) {\n      canvas.style.opacity = String(opacity);\n    }\n\n    this.postRender(gl, frameState);\n    return canvas;\n  }\n\n  /**\n   * Determine whether renderFrame should be called.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @return {boolean} Layer is ready to be rendered.\n   */\n  prepareFrameInternal(frameState) {\n    const layer = this.getLayer();\n    const vectorSource = layer.getSource();\n    const viewState = frameState.viewState;\n    const viewNotMoving =\n      !frameState.viewHints[ViewHint.ANIMATING] &&\n      !frameState.viewHints[ViewHint.INTERACTING];\n    const extentChanged = !equals(this.previousExtent_, frameState.extent);\n    const sourceChanged = this.sourceRevision_ < vectorSource.getRevision();\n\n    if (sourceChanged) {\n      this.sourceRevision_ = vectorSource.getRevision();\n    }\n\n    if (viewNotMoving && (extentChanged || sourceChanged)) {\n      const projection = viewState.projection;\n      const resolution = viewState.resolution;\n\n      const renderBuffer =\n        layer instanceof BaseVector ? layer.getRenderBuffer() : 0;\n      const extent = buffer(frameState.extent, renderBuffer * resolution);\n      vectorSource.loadFeatures(extent, resolution, projection);\n\n      this.ready = false;\n      let remaining = 3;\n      const rebuildCb = () => {\n        remaining--;\n        this.ready = remaining <= 0;\n        this.getLayer().changed();\n      };\n\n      this.polygonRenderer_.rebuild(\n        this.batch_.polygonBatch,\n        frameState,\n        'Polygon',\n        rebuildCb\n      );\n      this.lineStringRenderer_.rebuild(\n        this.batch_.lineStringBatch,\n        frameState,\n        'LineString',\n        rebuildCb\n      );\n      this.pointRenderer_.rebuild(\n        this.batch_.pointBatch,\n        frameState,\n        'Point',\n        rebuildCb\n      );\n      this.previousExtent_ = frameState.extent.slice();\n    }\n\n    this.helper.makeProjectionTransform(frameState, this.currentTransform_);\n    this.helper.prepareDraw(frameState);\n\n    return true;\n  }\n\n  /**\n   * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @param {import(\"../../Map.js\").FrameState} frameState Frame state.\n   * @param {number} hitTolerance Hit tolerance in pixels.\n   * @param {import(\"../vector.js\").FeatureCallback<T>} callback Feature callback.\n   * @param {Array<import(\"../Map.js\").HitMatch<T>>} matches The hit detected matches with tolerance.\n   * @return {T|undefined} Callback result.\n   * @template T\n   */\n  forEachFeatureAtCoordinate(\n    coordinate,\n    frameState,\n    hitTolerance,\n    callback,\n    matches\n  ) {\n    return undefined;\n  }\n\n  /**\n   * Clean up.\n   */\n  disposeInternal() {\n    this.worker_.terminate();\n    this.layer_ = null;\n    this.sourceListenKeys_.forEach(function (key) {\n      unlistenByKey(key);\n    });\n    this.sourceListenKeys_ = null;\n    super.disposeInternal();\n  }\n}\n\nexport default WebGLVectorLayerRenderer;\n","import GeoJSON from '../src/ol/format/GeoJSON.js';\nimport Layer from '../src/ol/layer/Layer.js';\nimport Map from '../src/ol/Map.js';\nimport OSM from '../src/ol/source/OSM.js';\nimport TileLayer from '../src/ol/layer/WebGLTile.js';\nimport VectorSource from '../src/ol/source/Vector.js';\nimport View from '../src/ol/View.js';\nimport WebGLVectorLayerRenderer from '../src/ol/renderer/webgl/VectorLayer.js';\nimport {asArray} from '../src/ol/color.js';\nimport {packColor} from '../src/ol/renderer/webgl/shaders.js';\n\nclass WebGLLayer extends Layer {\n  createRenderer() {\n    return new WebGLVectorLayerRenderer(this, {\n      fill: {\n        attributes: {\n          color: function (feature) {\n            const color = asArray(feature.get('COLOR') || '#eee');\n            color[3] = 0.85;\n            return packColor(color);\n          },\n          opacity: function () {\n            return 0.6;\n          },\n        },\n      },\n      stroke: {\n        attributes: {\n          color: function (feature) {\n            const color = [...asArray(feature.get('COLOR') || '#eee')];\n            color.forEach((_, i) => (color[i] = Math.round(color[i] * 0.75))); // darken slightly\n            return packColor(color);\n          },\n          width: function () {\n            return 1.5;\n          },\n          opacity: function () {\n            return 1;\n          },\n        },\n      },\n    });\n  }\n}\n\nconst osm = new TileLayer({\n  source: new OSM(),\n});\n\nconst vectorLayer = new WebGLLayer({\n  source: new VectorSource({\n    url: 'https://openlayers.org/data/vector/ecoregions.json',\n    format: new GeoJSON(),\n  }),\n});\n\nconst map = new Map({\n  layers: [osm, vectorLayer],\n  target: 'map',\n  view: new View({\n    center: [0, 0],\n    zoom: 1,\n  }),\n});\n"],"names":["workerMessageCounter","constructor","helper","worker","vertexShader","fragmentShader","customAttributes","this","helper_","worker_","program_","getProgram","attributes","rebuild","batch","frameState","geometryType","callback","renderInstructionsTransform","makeProjectionTransform","generateRenderInstructions","generateBuffers_","render","currentTransform","offsetX","invertVerticesBufferTransform","useProgram","bindBuffer","verticesBuffer","indicesBuffer","enableAttributes","renderCount","getSize","drawElements","messageId","messageType","message","id","type","renderInstructions","buffer","customAttributesCount","length","postMessage","handleMessage","event","received","data","removeEventListener","verticesBufferTransform","fromArrayBuffer","vertexBuffer","flushBufferData","indexBuffer","Float32Array","bind","addEventListener","Attributes","SEGMENT_START","SEGMENT_END","PARAMETERS","super","name","size","concat","map","attribute","totalInstructionsCount","verticesCount","geometriesCount","batchEntry","flatCoords","value","renderIndex","featureUid","entries","i","ii","flatCoordss","k","kk","feature","j","jj","polygonBatch","ringsCount","pointBatch","lineStringBatch","addFeatures","features","addFeature","geometry","getGeometry","addGeometry_","addFeatureEntryInPointBatch_","uid","addFeatureEntryInLineStringBatch_","addFeatureEntryInPolygonBatch_","ringsVerticesCounts","clearFeatureEntryInPointBatch_","entry","clearFeatureEntryInLineStringBatch_","clearFeatureEntryInPolygonBatch_","getType","getGeometries","geom","getPolygons","polygon","getLineStrings","line","getPoints","point","polygonGeom","getFlatCoordinates","getLinearRingCount","ringsVerticesCount","getEnds","end","ind","arr","push","getLinearRings","ring","pointGeom","lineGeom","changeFeature","removeFeature","clear","POSITION","INDEX","tmpCoords","packColor","color","array","DECODE_COLOR_EXPRESSION","FILL_VERTEX_SHADER","STROKE_VERTEX_SHADER","POINT_VERTEX_SHADER","toAttributesArray","obj","Object","keys","key","WebGLVectorLayerRenderer","layer","options","uniforms","projectionMatrixTransform","postProcesses","sourceRevision_","previousExtent_","currentTransform_","fillAttributes","opacity","fill","strokeAttributes","width","stroke","pointAttributes","fillVertexShader_","fillFragmentShader_","fillAttributes_","strokeVertexShader_","strokeFragmentShader_","strokeAttributes_","pointVertexShader_","pointFragmentShader_","pointAttributes_","batch_","source","getLayer","getSource","getFeatures","sourceListenKeys_","VectorEventType","handleSourceFeatureAdded_","handleSourceFeatureChanged_","handleSourceFeatureDelete_","handleSourceFeatureClear_","afterHelperCreated","polygonRenderer_","pointRenderer_","lineStringRenderer_","renderFrame","gl","getGL","preRender","vectorSource","projection","viewState","multiWorld","getWrapX","canWrapX","projectionExtent","getExtent","extent","worldWidth","endWorld","Math","ceil","world","floor","finalizeDraw","canvas","getCanvas","layerStatesArray","layerIndex","parseFloat","style","String","postRender","prepareFrameInternal","viewNotMoving","viewHints","ViewHint","extentChanged","sourceChanged","getRevision","resolution","renderBuffer","BaseVector","getRenderBuffer","loadFeatures","ready","remaining","rebuildCb","changed","slice","prepareDraw","forEachFeatureAtCoordinate","coordinate","hitTolerance","matches","disposeInternal","terminate","layer_","forEach","WebGLLayer","Layer","createRenderer","get","_","round","osm","OSM","vectorLayer","Vector","url","format","GeoJSON","Map","layers","target","view","View","center","zoom"],"sourceRoot":""}